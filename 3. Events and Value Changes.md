# 3. Events and Value Changes

In the previous chapter, we got a brief introduction to handling events reactively. But RxJavaFX is equipped to handle almost any specialized event for various `Node` controls. JavaFX also utilizes `Property` values, and their value changes  can be turned into Observables easily as well. We will also cover some new operators to combine multiple value streams in useful ways. 

##Turning JavaFX Events into Observables

To create an `Observable` for *any* event on *any* `Node`, you can target the `Node`'s events using a `JavaFxObservable.fromNodeEvents()` for Java, and the `Node` extension function `events()` for the Kotlin. You can pass the `EventType` you are targeting as the parameter, and an `Observable` emitting that `EventType` will be returned. 

Here is an example with a `ListView` containing `String` items representing the integers 0 through 9. Whenever a numeric key is pressed on your keyboard, it will select that item in the `ListView`. 

**Java**
```java

public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();

        ListView<String> listView = new ListView<>();

        for (int i = 0; i <= 9; i++) {
            listView.getItems().add(String.valueOf(i));
        }

        JavaFxObservable.fromNodeEvents(listView, KeyEvent.KEY_TYPED)
                .map(KeyEvent::getCharacter)
                .filter(s -> s.matches("[0-9]"))
                .subscribe(s -> listView.getSelectionModel().select(s));

        vBox.getChildren().add(listView);
        stage.setScene(new Scene(vBox));
        stage.show();
    }
}

```

**Kotlin**
```kotlin
class MyApp: App(MyView::class)

class MyView: View() {

    override val root = vbox {

        listview<String> {
            (0..9).asSequence().map { it.toString() }.forEach { items.add(it) }

            events(KeyEvent.KEY_TYPED)
                .map { it.character }
                .filter { it.matches(Regex("[0-9]")) }
                .subscribe { selectionModel.select(it)}
        }
    }
}
```

**RENDERED UI:**

![](http://i.imgur.com/P1DAhmu.png)

Notice above we targeted `KeyEvent.KEY_TYPED` and the returned `Observable` will emit a `KeyEvent` item every time a `KEY_TYPED` event occurs. Some events like this one have helpful information on them, such as the character `String` representing the value for that key. We used a [regular expression](http://www.codeproject.com/Articles/9099/The-Minute-Regex-Tutorial) to validate the character `String` was a single numeric character, and filter emissions that are not. Then we selected it in the `ListView`'s `SelectionModel`. 

>If you want to combine keystrokes to form entire Strings rather than a series of single characters, you will want to use [Backpressure Operators](https://github.com/ReactiveX/RxJava/wiki/Backpressure) to combine them based on timing windows. You can read more about this in Appendix X. 

Here is another example that targets `MouseEvent.MOVE_MOVED` events on a `Rectangle`. As you move your cursor over the `Rectangle`, the `x` and `y` position of the cursor should be concatenated and pushed into a `Label` above it. 

**Java**
```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();

        Label positionLabel = new Label();
        Rectangle rectangle = new Rectangle(200,200);
        rectangle.setFill(Color.RED);

        JavaFxObservable.fromNodeEvents(rectangle, MouseEvent.MOUSE_MOVED)
                .map(me -> me.getX() + "-" +  me.getY())
                .subscribe(positionLabel::setText);

        vBox.getChildren().addAll(positionLabel,rectangle);
        stage.setScene(new Scene(vBox));
        stage.show();
    }
}
```

**Kotlin**
```kotlin
class MyApp: App(MyView::class)

class MyView: View() {

    override val root = vbox {

        val positionLabel = label()

        rectangle(height = 200.0, width = 200.0) {

            fill = Color.RED

            events(MouseEvent.MOUSE_MOVED)
                .map { "${it.x}-${it.y}" }
                .subscribe { positionLabel.text = it }
        }
    }
}
```

**RENDERED UI:**
![](http://i.imgur.com/XgiW8BV.png)

JavaFX is packed with events everywhere, and you will need to know which events you are targeting depending on the `Node` control. 

