# 4. Collections and Data

Any sizable application needs to work with data and collections of items. One of the greatest utilities to come out of JavaFX are ObservableCollections such as `ObservableList`, `ObservableSet`, and `ObservableMap`. These implementations of `List`, `Set`, and `Map` are built specifically for JavaFX to notify the UI when it has been modified, and any control built off it will visually update accordingly.

However, these ObservableCollections can have custom listeners added to them, and this creates an easy gateway to reactively work with data and collections. The idea of emitting a collection every time it changes allows some very powerful reactive transformations, and we will see plenty of examples in this chapter. 

>Do not confuse the JavaFX `ObservableList`, `ObservableSet`, and `ObservableMap` to somehow be natively related to the RxJava `Observable`. This is not the case. Remember that JavaFX's concept of an `Observable` is not the same as an RxJava `Observable`, as we have seen with JavaFX's `ObservableValue`. However we will turn all of these into an RxJava `Observable` to fully unleash their capabilities as an `Observable`.

##Emitting an Observable Collection

Let's create a simple application backed by an `ObservableList` of Strings. There will be a `ListView<String>` to display these values, and another `ListView<Integer>` that will hold the distinct lengths. We will use a `TextField` and  a `Button` to add Strings to the `ObservableList`, and both ListViews should update accordingly with each addition. 

You should get a UI that looks like Figure 4.1 when you run the code below. 

**Java**
```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox root = new VBox();

        ObservableList<String> values =
                FXCollections.observableArrayList("Alpha","Beta","Gamma");

        Label valuesLabel = new Label("VALUES");
        ListView<String> valuesListView = new ListView<>(values);

        Label distinctLengthsLabel = new Label("DISTINCT LENGTHS");
        ListView<Integer> distinctLengthsListView = new ListView<>();

        JavaFxObservable.fromObservableList(values)
                .flatMap(list ->
                        Observable.from(list).map(String::length).distinct().toList()
                ).subscribe(lengths -> distinctLengthsListView.getItems().setAll(lengths));

        TextField inputField = new TextField();
        Button addButton = new Button("ADD");

        JavaFxObservable.fromActionEvents(addButton)
                .map(ae -> inputField.getText())
                .filter(s -> s != null && !s.trim().isEmpty())
                .subscribe(s -> {
                    values.add(s);
                    inputField.clear();
                });

        root.getChildren().addAll(valuesLabel,valuesListView,distinctLengthsLabel,
                distinctLengthsListView,inputField,addButton);

        stage.setScene(new Scene(root));
        stage.show();
    }
}
```

**Kotlin**
```
class MyApp: App(MyView::class)

class MyView: View() {

    val values = FXCollections.observableArrayList("Alpha","Beta","Gamma")

    override val root = vbox {

        label("VALUES")
        listview(values)

        label("DISTINCT LENGTHS")
        listview<Int> {
            values.onChangedObservable()
                .flatMap {
                    it.toObservable().map { it.length }.distinct().toList()
                }.subscribe {
                    items.setAll(it)
                }
        }


        label("INPUT")
        val inputField = textfield()

        button("ADD").actionEvents()
            .map { inputField.text }
            .filter { it != null && !it.trim().isEmpty()}
            .subscribe {
                values.add(it)
                inputField.clear()
            }
    }
```

**Figure 4.1**

![](http://i.imgur.com/Jbe1BE4.png)

Go ahead and type in "Delta", then click "ADD". Then do the same for "Epsilon". You should now see Figure 4.2.

**Figure 4.2**

![](http://i.imgur.com/uchjCuI.png)

Did you see that? Not only did "Delta" and "Epsilon" get added to the top `ListView`, but the distinct length of 7 was added to the bottom one. So how exactly was this made possible?

Study the code above very closely. We declared an `ObservableList<String>` called `values`. All the magic is built around it. We created an `Observable<ObservableList<String>>` off it using `JavaFxObservable.fromObservableList()`. While the type looks a little strange the idea is very simple: every time the `ObservableList<String>` changes, it is pushed through the `Observable<ObservableList<String>>` in its entirety as an emission. It will also emit the `ObservableList`on subscription as the initial emission, just like the `ObservableValue` factories we worked with in the last chapter.

This is a very powerful pattern because as we have just seen, we can transform this `ObservableList` emission inside a `flatMap()` any way we want. In this example, we effectively created a new `ObservableList<Integer>` that receives the distinct lengths of the `ObservableList<String>`. 

Let's leverage this idea in another way. Instead of holding the distinct lengths in another `ObservableList<Integer`, let's concatenate them as a `String` and push it into a `Label`'s text.

**Java**

```java

public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox root = new VBox();

        ObservableList<String> values =
                FXCollections.observableArrayList("Alpha","Beta","Gamma");

        Label valuesLabel = new Label("VALUES");
        ListView<String> valuesListView = new ListView<>(values);

        Label distinctLengthsLabel = new Label("DISTINCT LENGTHS");
        Label distinctLengthsConcatLabel= new Label();
        distinctLengthsConcatLabel.setTextFill(Color.RED);

        JavaFxObservable.fromObservableList(values)
                .flatMap(list ->
                        Observable.from(list)
                                .map(String::length)
                                .distinct().reduce("",(x,y) -> x + (x.equals("") ? "" : "|") + y)
                ).subscribe(distinctLengthsConcatLabel::setText);

        TextField inputField = new TextField();
        Button addButton = new Button("ADD");

        JavaFxObservable.fromActionEvents(addButton)
                .map(ae -> inputField.getText())
                .filter(s -> s != null && !s.trim().isEmpty())
                .subscribe(s -> {
                    values.add(s);
                    inputField.clear();
                });

        root.getChildren().addAll(valuesLabel,valuesListView,distinctLengthsLabel,
                distinctLengthsConcatLabel,inputField,addButton);

        stage.setScene(new Scene(root));
        stage.show();
    }
}
```

**Kotlin**

```kotlin
class MyApp: App(MyView::class)

class MyView: View() {

    val values = FXCollections.observableArrayList("Alpha","Beta","Gamma")

    override val root = vbox {

        label("VALUES")
        listview(values)

        label("DISTINCT LENGTHS")
        label {
            textFill = Color.RED

            values.onChangedObservable()
                .flatMap {
                    it.toObservable()
                            .map { it.length }
                            .distinct()
                            .reduce("") { x,y -> x + (if (x == "") "" else "|") + y }
                }.subscribe {
                    text = it
                }
        }


        label("INPUT")
        val inputField = textfield()

        button("ADD").actionEvents()
            .map { inputField.text }
            .filter { it != null && !it.trim().isEmpty()}
            .subscribe {
                values.add(it)
                inputField.clear()
            }
    }
}
```

**Figure 4.3**

![](http://i.imgur.com/5KJCtZ4.png)

Awesome, right? Without actually creating a JavaFX `Binding`, we are pushing a transformation of the `ObservableList` source and driving a `Label`'s text with it. We will learn about creating an actual `Binding` off an `Observable` later in this book, but for a lot of cases we can simply use an `Observable` and `Subscriber` to easily synchronize and transform pushed data and events., without being restricted to a `Binding`!

Note also there are factories for `ObservableSet` and `ObservableMap` as well to accomplish the same behavior. `JavaFxObservable.fromObservableSet()` will emit the `ObservableSet` every time it changes, 

**Java**
```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        ObservableSet<String> values =
                FXCollections.observableSet("Alpha","Beta","Gamma");

        JavaFxObservable.fromObservableSet(values)
                .subscribe(System.out::println);

        values.add("Delta");
        values.add("Alpha"); //no effect

        values.remove("Beta");

		System.exit(0); //quit
    }
}
```

**Kotlin**

```kotlin
class MyApp: App(MyView::class)

class MyView: View() {
    override val root = vbox {
        val values = FXCollections.observableSet("Alpha","Beta","Gamma")

        values.onChangedObservable()
	        .subscribe { println(it) }

        values.add("Delta")
        values.add("Alpha") //no effect

        values.remove("Beta")

		System.exit(0) //quit 
    }
}
```
**OUTPUT:**

```
[Alpha, Gamma, Beta]
[Alpha, Gamma, Delta, Beta]
[Alpha, Gamma, Delta]
```

 `JavaFxObservable.fromObservableMap()` will emit the`ObservableMap` every time it changes. 

**Java**
```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        ObservableMap<Integer,String> values =
                FXCollections.observableHashMap();

        JavaFxObservable.fromObservableMap(values)
                .subscribe(System.out::println);

        values.put(1,"Alpha");
        values.put(2,"Beta");
        values.put(3,"Gamma");
        values.put(1,"Alpha"); //no effect
        values.put(3,"Delta");
        values.remove(2);
        
        System.exit(0);
    }
}
```

**Kotlin**
```kotlin
class MyApp: App(MyView::class)

class MyView: View() {
    override val root = vbox {
        val values = FXCollections.observableHashMap<Int, String>()

        JavaFxObservable.fromObservableMap(values)
                .subscribe { println(it) }

        values.put(1, "Alpha")
        values.put(2, "Beta")
        values.put(3, "Gamma")
        values.put(1, "Alpha") //no effect
        values.put(3, "Delta")
        values.remove(2)
		
		System.exit(0);
    }
}
```

**OUTPUT:**
```
{}
{1=Alpha}
{1=Alpha, 2=Beta}
{1=Alpha, 2=Beta, 3=Gamma}
{1=Alpha, 2=Beta, 3=Delta}
{1=Alpha, 3=Delta}
```

## Add, Remove, and Update Events

There are factories for `ObservableList`, `ObservableSet`, and `ObservableMap` to emit specific change events against those collections. To get an emission for each modification to an `ObservableList`, you can use `JavaFxObservable.fromObservableListChanges()`. It will pair each affected element `T` with a `Flag` in a `ListChange` emission. The `Flag` is an enum with possible values `ADDED`, `REMOVED`, or `UPDATED`. 

**Java**
```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        ObservableList<String> values =
                FXCollections.observableArrayList("Alpha","Beta","Gamma");

        JavaFxObservable.fromObservableListChanges(values)
                .subscribe(System.out::println);

        values.add("Delta");
        values.add("Epsilon");
        values.remove("Alpha");
        values.set(2,"Eta");

        System.exit(0);
    }
}
```


**Kotlin**
```kotlin
class MyApp: App(MyView::class)

class MyView: View() {
    override val root = vbox {
        val values = FXCollections.observableArrayList("Alpha", "Beta", "Gamma")

        values.changes().subscribe { println(it) }

        values.add("Delta")
        values.add("Epsilon")
        values.remove("Alpha")
        values[2] = "Eta"

        System.exit(0)
    }
}
```

**OUTPUT:**

```
ADDED Delta
ADDED Epsilon
REMOVED Alpha
ADDED Eta
REMOVED Delta
```

There are equivalent factories for `ObservableMap` and `ObservableSet` as well, named `JavaFxObservable.fromObservableMapChanges()` and `JavaFxObservable.fromObservableSetChanges()` respectively. 

Note that this factory has no initial emission. It will only emit changes going forward after subscription. A `ListChange` is emitted with the affected value and whether it was `ADDED`, `REMOVED`, or `UPDATED`. Interestingly, note that calling `set()` on the `ObservableList` will replace an element at a given index, and result in two emissions: one for the `REMOVED` item, and another for the `ADDED` item. When we set index `2` to "Eta", it replaced "Delta" which was `REMOVED`, and then "Eta" was `ADDED`. 

An `UPDATED` occurs when an `ObservableValue` property of a given element `T` in an `ObservableList<T>` changes. This is a less-known feature in JavaFX but can be enormously helpful. 

Consider a `User` class with an updateable `Property` called `name`. 

**Java**
```java
class User {
    private final int id;
    private final Property<String> name = 
	    new SimpleStringProperty();

    User(int id, String name) {
        this.id = id;
        this.name.setValue(name);
    }
    public int getId() {
        return id;
    }
    public Property<String> nameProperty() {
        return name;
    }
    @Override
    public String toString() {
        return id + "-" + name.getValue();
    }
}
```

**Kotlin**

```kotlin
class User(val id: Int, name: String) {
    var name: String by property(name)

    fun nameProperty() = getProperty(User::name)

    override fun toString() = "$id-$name"
}
```

Whenever this `name` property for any `User` in the `ObservableList<User>` changes, this change will be pushed as an emission categorized in a `ListChange` as an `UPDATED`. 

**Java**
```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        ObservableList<User> values =
                FXCollections.observableArrayList(user -> new ObservableValue[]{user.nameProperty()});

        JavaFxObservable.fromObservableListChanges(values)
                .subscribe(System.out::println);

        values.add(new User(503,"Tom Nield"));
        values.add(new User(504,"Jason Shwartz"));

        values.get(0).nameProperty().setValue("Thomas Nield");

        System.exit(0);
    }

}
```

**Kotlin**

```kotlin
class MyApp: App(MyView::class)

class MyView: View() {
    override val root = vbox {
        val values = FXCollections.observableArrayList<User> { user ->
            arrayOf<ObservableValue<*>>(user.nameProperty()) 
        }

        JavaFxObservable.fromObservableListChanges(values)
                .subscribe { println(it) }

        values.add(User(503, "Tom Nield"))
        values.add(User(504, "Jason Shwartz"))

        values[0].nameProperty().value = "Thomas Nield"

        System.exit(0)
    }
}
```

**OUTPUT:**

```
ADDED 503-Tom Nield
ADDED 504-Jason Shwartz
UPDATED 503-Thomas Nield
```

We declared a lambda specifying an array of `ObservableValue` properties we are interested in listening to, which in this case is only the `name` property. When the first element containing the `User` named "Tom Nield" had its `name` property changed to `Thomas Nield`, it was emitted as a change. This will also work with the `fromObservableList()` factory we saw earlier, and the entire `ObservableList<T>` will be pushed every time any specified property on any element `T` changes. 

This can be very helpful to react not just to items in the list being added or removed, but also when their properties are modified. You can then use this behavior to, for example, drive updates to concatenations.

**Java**
```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        ObservableList<User> values =
                FXCollections.observableArrayList(user -> new ObservableValue[]{user.nameProperty()});

        JavaFxObservable.fromObservableList(values)
                .flatMap(list ->
                    Observable.from(list)
                        .map(User::getName)
                        .reduce("",(u1,u2) -> u1 + (u1.equals("") ? "" : ", ") + u2)
                )
                .subscribe(System.out::println);

        values.add(new User(503,"Tom Nield"));
        values.add(new User(504,"Jason Shwartz"));

        values.get(0).nameProperty().setValue("Thomas Nield");

        System.exit(0);
    }
}

```

**Kotlin**
```kotlin
class MyApp: App(MyView::class)

class MyView: View() {
    override val root = vbox {
        val values = FXCollections.observableArrayList<User> { user ->
            arrayOf<ObservableValue<*>>(user.nameProperty())
        }

        JavaFxObservable.fromObservableList(values)
                .flatMap {
                    it.toObservable().map {it.name }
                        .reduce("") { u1,u2 -> u1 + (if (u1 == "") "" else ", ") + u2 }
                }
                .subscribe { println(it) }

        values.add(User(503, "Tom Nield"))
        values.add(User(504, "Jason Shwartz"))

        values[0].nameProperty().value = "Thomas Nield"

        System.exit(0)
    }
}

```

**OUTPUT:**
```

Tom Nield
Tom Nield, Jason Shwartz
Thomas Nield, Jason Shwartz
```

Note also there are factories that target only `ADDED`, `REMOVED`, and `UPDATED` events. These will only emit items corresponding to those event types. These also are available under the `JavaFxObservable` utility class. Here is a complete list of these additional factories, as well as the factories we covered so far. 

**Figure 4.4** - JavaFX Collection Factories
|Collection Type|Java Factory|Kotlin Extension|Return Type|Description
|---|---|---|---
|ObservableList&lt;T>|fromObservableList()|onChangedObservable()|Observable&lt;ObservableList&lt;T>>|Emits entire `ObservableList<T>` every time it changes
|ObservableList&lt;T>|fromObservableListAdds()|additions()|Observable&lt;T>|Emits added items
|ObservableList&lt;T>|fromObservableListRemovals()|removals()|Observable&lt;T>|Emits removed items
|ObservableList&lt;T>|fromObservableListUpdates()|updates()|Observable&lt;T>|Emits updated items
|ObservableSet&lt;T>|fromObservableSet()|onChangedObservable()|Observable&lt;ObservableSet&lt;T>>|Emits entire `ObservableSet<T>` every time it changes
|ObservableSet&lt;T>|fromObservableSetAdds()|additions()|Observable&lt;T>|Emits added items
|ObservableSet&lt;T>|fromObservableSetRemovals()|removals()|Observable&lt;T>|Emits removed items
|ObservableSet&lt;T>|fromObservableSetUpdates()|updates()|Observable&lt;T>|Emits updated items
|ObservableMap&lt;T>|fromObservableMap()|onChangedObservable()|Observable&lt;ObservableMap&lt;K,T>>|Emits entire `ObservableMap<K,T>` every time it changes
|ObservableMap<&lt;K,T>|fromObservableMapAdds()|additions()|Observable&lt;Map.Entry&lt;K,T>>|Emits added items
|ObservableMap&lt;K,T>|fromObservableMapRemovals()|removals()|Observable&lt;Map.Entry&lt;K,T>>|Emits removed items
|ObservableMap&lt;K,T>|fromObservableMapUpdates()|updates()|Observable&lt;Map.Entry&lt;K,T>>|Emits updated items


