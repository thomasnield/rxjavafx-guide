# 5. Combining Observables

So far in this book, we have merely set the stage to make Rx useful. We learned how to emit JavaFX Events, ObservableValues, and ObservableCollections through RxJava Observables. But there is only so much you can do when a reactive stream is driven off one source. When you have emissions from multiple Observables being joined together in some form, we truly find this is where the "rubber meets the road". 

There are several ways to combine emissions from multiple Observables, and we will cover many of these "combine operators". 


## Concatenation

One of the simplest ways to combine Observables is to use the `concat()` operators. You can specify two or more Observables emitting the same type `T` and it will fire each one's emisssions sequentially, one after the other. 

**Java**

```java
Observable<String> source1 = Observable.just("Alpha","Beta","Gamma");
Observable<String> source2 = Observable.just("Delta","Epsilon");

Observable.concat(source1,source2)
	.map(String::length)
	.toList()
	.subscribe(System.out::println);

```

**Kotlin**

```kotlin
val source1 = Observable.just("Alpha","Beta","Gamma")
        val source2 = Observable.just("Delta","Epsilon")

Observable.concat(source1,source2)
        .map { it.length }
        .toList()
        .subscribe { println(it) }
```

**OUTPUT:**

```
[5, 4, 5, 5, 7]
```

It is very critical to note that `onCompleted()` must be called on each `Observable` so it moves on to the next one. If you have an `Observable` in a concatenated operation, it will hold up the line by infinitely emitting items, forever keeping any Observables after it from getting fired. 

You do not have to use a factory to accomplish this, as concatentation is also available as an operator. This should yield the same output.

**Java**

```java
Observable<String> source1 = Observable.just("Alpha","Beta","Gamma");
Observable<String> source2 = Observable.just("Delta","Epsilon");

source1.concatWith(source2)
	.map(String::length)
	.toList()
	.subscribe(System.out::println);
```

**Kotlin**

```kotlin
val source1 = Observable.just("Alpha","Beta","Gamma")
val source2 = Observable.just("Delta","Epsilon")

source1.concatWith(source2)
	.map { it.length }
	.toList()
	.subscribe { println(it) }
```

**OUTPUT:**

```
[5, 4, 5, 5, 7]
```

If you want to do a concenation but put another `Observable` in front rather than after), you can use `startWith()` instead. 


**Java**

```java
Observable<String> source1 = Observable.just("Alpha","Beta","Gamma");
Observable<String> source2 = Observable.just("Delta","Epsilon");

source1.startWith(source2)
    .subscribe(System.out::println);
```

**Kotlin**

```kotlin
val source1 = Observable.just("Alpha","Beta","Gamma")
val source2 = Observable.just("Delta","Epsilon")

source1.startWith(source2)
        .subscribe { println(it) }
```

**OUTPUT:**

```
Delta
Epsilon
Alpha
Beta
Gamma
```

Again, this operator is not one you would want to use with infinite Observables. This means it is likely you would use this for data-driven Observables and not UI events. Any infinite `Observable` in a concatenation will prevent any following Observables from ever emitting. Of course, you can specify an infinite `Observable` to be the last `Observable`. That way it is not holding up any other Observables because none are behind it.  When you want to simultaneously combine all emissions from all Observables, you might want to consider using `merge()` which we will cover next. .

## Merging

Merging is almost like concatenation but with one important difference: it will combine all Observables of a given emission type `T` simultaneously. This means all emissions from all Observables are merged together into a single stream without any regard for order or `onCompleted()` being called. 

This is pretty helpful to merge multiple UI event sources since merging works fine with infinite Observables. For instance, you can consolidate the `ActionEvent` emissions of two buttons into a single `Observable<ActionEvent>` using `Observable.merge()`. (Figure 5.1).

**Java**

```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {
        VBox root = new VBox();
        
        Button firstButton = new Button("Press Me");
        Button secondButton = new Button("Press Me Too");

        Observable.merge(
                JavaFxObservable.fromActionEvents(firstButton),
                JavaFxObservable.fromActionEvents(secondButton)
        ).subscribe(i -> System.out.println("You pressed one of the buttons!"));

        root.getChildren().addAll(firstButton,secondButton);
        stage.setScene(new Scene(root));
        stage.show();
    }
}
```

**Kotlin**

```kotlin
class MyApp: App(MyView::class)

class MyView: View() {
    override val root = vbox {
        val buttonUp = button("Press Me")
        val buttonDown = button("Press Me Too")

        Observable.merge(
                buttonUp.actionEvents(),
                buttonDown.actionEvents()
        )
        .subscribe {
            System.out.println("You pressed one of the buttons!")
        }
    }
}
```

**Figure 5.1**

![](http://i.imgur.com/rxbqqSC.png)

When you press either `Button`, it will consolidate the emissions into a single `Observable<ActionEvent>` which goes to a single `Subscriber`. 

Let's make this more interesting. Let's make two Buttons, labeled "UP" and "DOWN", and map their `ActionEvent` to either a `1` or `-1` respectively. Using a `scan()` we can create a rolling sum of these emissions and push the incrementing/decrementing number to a `Label` (Figure 5.2).

**Java**

```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {
        VBox root = new VBox();

        Label label = new Label("0");

        Button buttonUp = new Button("UP");
        Button buttonDown = new Button("DOWN");

        Observable.merge(
                JavaFxObservable.fromActionEvents(buttonUp).map(ae -> 1),
                JavaFxObservable.fromActionEvents(buttonDown).map(ae -> -1)
        ).scan(0,(x,y) -> x + y)
         .subscribe(i -> label.setText(i.toString()));

        root.getChildren().addAll(label,buttonUp,buttonDown);
        stage.setScene(new Scene(root));
        stage.show();
    }
}
```

**Kotlin**

```kotlin

class MyApp: App(MyView::class)

class MyView: View() {
    override val root = vbox {
        val label = label("0")
        val buttonUp = button("UP")
        val buttonDown = button("DOWN")

        Observable.merge(
                buttonUp.actionEvents().map { 1 },
                buttonDown.actionEvents().map { -1 }
        ).scan(0) { x,y -> x + y }
        .subscribe {
            label.text = it.toString()
        }
    }
}
```

**Figure 5.2**

![](http://i.imgur.com/cSWclq8.png)

When you press the "UP" `Button`, it will increment the integer in the `Label`.  When you press the "DOWN" `Button`, it will decrement it. All we did was take these two resulting Observables returned from the `map()` operator, and merged them. The `1` or `-1` is then pushed to the `scan()` operation where it is emitted as a rolling total.

There is also an operator version you can use instead of the factory to merge an existing `Observable<T>` with another `Observable<T>`

**Java**

```java
JavaFxObservable.fromActionEvents(buttonUp).map(ae -> 1)
	.mergeWith(
		JavaFxObservable.fromActionEvents(buttonDown).map(ae -> -1)
    ).scan(0,(x,y) -> x + y)
    .subscribe(i -> label.setText(i.toString()));
```

**Kotlin**

```kotlin
 buttonUp.actionEvents().map { 1 }
	.mergeWith(
	    buttonDown.actionEvents().map { -1 }
	).scan(0) { x,y -> x + y }
	.subscribe {
	    label.text = it.toString()
	}
```

Just like concatentaiton, you can merge as many Observables as you want.

## Zip

## Combine Latest

