# 10. Decoupling Reactive Streams

In this book, we kept our examples fairly coupled and did not bring any UI code separation patterns. This was to keep the focus on Rx topics and not distract away from them. But in this chapter, we will introduce how you can separate Observables and Observers cleanly so they are not coupled with each other, even if they are in different parts of the UI. This aids goals to create effective code separation patterns and increase maintainability of complex applications.

RxJava has a special reactive type called a `Subject`, which comes in a number of implementations. A `Subject` operates as both an `Observable` and an `Observer`. However, you need to be selective when to use Subjects as they can introduce antipatterns. They can come in handy to decouple reactive streams by having multiple "sources" subscribe a `Subject` to their emissions, and then that `Subject` will pass those emissions downstream to any receiving Observers. Subjects automatically multicast as well.


## Using the PublishSubject

A `Subject` cam act as a proxy between one or more source Observables and one or more Observers. The most vanilla type of `Subject` is the `PublishSubject`, which can be called using `PublishSubject.create()`. It will simply relay emissions from one or more upstream sources to one or more downstream Observers, without any additional behaviors.

Below, we do a simple separation between the source of text input values and an `Observer` that consumes them by putting them in a `Label`. The `Subject` will act as a proxy between them.

**Java**

```java
import io.reactivex.rxjavafx.observables.JavaFxObservable;
import io.reactivex.subjects.PublishSubject;
import io.reactivex.subjects.Subject;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class JavaFxApp extends Application {

    private final Subject<String> textInputs = PublishSubject.create();

    @Override
    public void start(Stage stage) throws Exception {

        TextField textField = new TextField();
        Label label = new Label();

        //pass emissions to the Subject
        JavaFxObservable.valuesOf(textField.textProperty()).subscribe(textInputs);

        //receive emissions from the Subject
        textInputs.map(s -> new StringBuilder(s).reverse().toString())
                .subscribe(label::setText);

        VBox vBox = new VBox(textField, label);

        stage.setScene(new Scene(vBox));
        stage.show();
    }
}
```

**Kotlin**

```kotlin

import com.github.thomasnield.rxkotlinfx.toObservable
import io.reactivex.subjects.PublishSubject
import tornadofx.*

class MyApp: App(MyView::class)

class MyView : View("My View") {

    val textInputs = PublishSubject.create<String>()

    override val root = vbox {
        textfield {
            textProperty()
                    .toObservable()
                    .subscribe(textInputs)
        }

        label {
            textInputs.map(String::reversed)
                    .subscribe { text = it }
        }
    }
}
```

### Using a Subject in a Model

Typically, you will hold the `Subject` in a separate model class of some sort to support your JavaFX applications, and relay emissions from one component to another in an EventBus-like fashion. This is helpful to not only broadcast universal events throughout your application, but also provide several sources to drive a single event.

**Java**

```java
import io.reactivex.Observable;
import io.reactivex.subjects.PublishSubject;
import io.reactivex.subjects.Subject;
import javafx.event.ActionEvent;


public class MyEventModel {

    private MyEventModel() {}

    private static final MyEventModel instance = new MyEventModel();

    public static MyEventModel getInstance() {
        return instance;
    }

    private final Subject<ActionEvent> refreshRequests = PublishSubject.create();

    public Observable<ActionEvent> getRefreshRequests() {
        return refreshRequests;
    }
}
```

**Kotlin**

```kotlin
import javafx.event.ActionEvent
import io.reactivex.subjects.PublishSubject

object MyEventModel {
    val refreshRequests = PublishSubject.create<ActionEvent>()
}
```

In this `MyEventModel` we have a `Subject<ActionEvent>` that handles `refreshRequests`, Let's say we wanted three events to drive a refresh: a `Button`, a `MenuItem`, and a key combination "CTRL + R" on a `TableView`.

If you declare these Observables in three separate places throughtout your UI code, you can add each of them to this `CompositeObservable`.

**Java**

```java
//make refresh Button
Button button = new Button("Refresh");
JavaFxObservable.actionEventsOf(button)
  .subscribe(MyEventModel.getInstance().getRefreshRequests());


//make refresh MenuItem
MenuItem menuItem = new MenuItem("Refresh");
JavaFxObservable.actionEventsOf(menuItemClicks)
  .subscribe(MyEventModel.getInstance().getRefreshRequests());

//CTRL + R hotkeys on a TableView
TableView<MyType> tableView = new TableView<>();

    JavaFxObservable.eventsOf(tableView, KeyEvent.KEY_PRESSED)
        .filter(ke -> ke.isControlDown() && ke.getCode().equals(KeyCode.R))
        .map(ke -> new ActionEvent());
        .subscribe(MyEventModel.getInstance().getRefreshRequests());
```

**Kotlin**

```kotlin
//make refresh button
val button = Button("Refresh")
button.actionEvents().subscribe(MyEventModel.refreshRequests)

//make refresh MenuItem
val menuItem = MenuItem("Refresh")
menuItem.actionEvents().subscribe(MyEventModel.refreshRequests)

//CTRL + R hotkeys on a TableView
val tableView = TableView<MyType>();
tableView.events(KeyEvent.KEY_PRESSED)
    .filter { it.isControlDown && it.code == KeyCode.R }
    .map { ActionEvent() }
    .subscribe(MyEventModel.refreshRequests)
```

These three event sources are now proxied through one `Subject`. You can then have one or more Observers `subscribe()` to this `Subject`, and they will respond to any of these three sources requesting a refresh.

**Java**

```java
//subscribe to refresh events
MyEventModel.getInstance()
    .getRefreshRequests()
    .subscribe(ae -> refresh());
```

**Kotlin**

```kotlin
MyEventModel.refreshRequests
    .subscribe { refresh() }
```

You can set up as many models as you like with as many Subjects as you like to pass different data and events back-and-forth throughout your application.

## Other Subject Types

There are a couple of other `Subject` implementations to be aware of. `BehaviorSubject` will cache the last emission that will be replayed to every new `Observer`, which can be helpful to always broadcast the latest value selected in a control. `ReplaySubject` will replay all values and indefinitely cache them. `AsyncSubject` will broadcast only the last value after the source calls `onComplete()`, and `UnicastSubject` will cache emissions until it gets the first downstream `Observer`, which it will emit all the items to and then flush its cache.

You can learn more about these subjects in Rx documentation as well as the _Learning RxJava_ Packt Book.

## Summary

In this chapter we covered how to separate reactive streams between UI components with the `Subject`, which can serve as a proxy between Observable sources and downstream Observers. You can put `Subject` instances in a backing class to serve as an Rx-flavored event bus to relay data and events. Use the `Subject` to consolidate mutliple event sources that drive the same action, or to cleanly separate your Observable sources and terminal Observers.

# Closing

You have reached the end of this book. Congrats! Keep researching RxJava and learn what it can do inside and outside of JavaFX. You will find it is used on Android via the RxAndroid and RxBindings libraries, as well as on backend development with RxNetty and other frameworks. I encourage you to keep learning the various operators and check out books and online resources to grow your proficiency.

I highly encourage reading my Packt book _Learning RxJava_ to get more thorough knowledge of RxJava beyond JavaFX applications. I wrote it in the same style and spirit as this book, with the intent of helping the largest number of people possible. The book can be purchased on [Packt](https://www.packtpub.com/application-development/learning-rxjava), [Amazon](http://a.co/d7Wli4l ), and other book retailers. It is also available via subscription to [O'Reilly Safari](https://www.safaribooksonline.com/) and [Packt Mapt](https://www.packtpub.com/mapt/).

https://www.packtpub.com/application-development/learning-rxjava

Please follow me on Twitter @thomasnield9727 for updates on all things Rx. If you have any issues, questions, or concerns please feel free to file an issue or email me at thomasnield@live.com.

Until next time!

Thomas Nield
