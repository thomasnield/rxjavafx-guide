# 2. RxJava Fundamentals

RxJava has two core types: the `Observable` and the `Subscriber`. In the simplest definition, an **Observable** *pushes* things. For a given `Observable<T>`, it will push items of type `T` through a series of operators that form other Observables, and finally the **Subscriber** is what consumes the items at the end of the chain.

Each pushed `T` item is known as an **emission**. Usually there is a finite number of emissions, but sometimes there can be infinite. An emission can represent either data or an event (or both!). This is where the power of reactive programming differentiates itself from Java 8 Streams and Kotlin Sequences. It has a notion of *emissions over time*, and we will explore that later in this chapter. 

If you have decent experience with RxJava already, ysou are welcome to skip this chapter. In later chapters you may encounter RxJava concepts that are already familiar, but be sure to not skip these as these concepts are often introduced from a JavaFX perspective. 

## The `Observable` and `Subscriber`

As stated earlier, an **Observable** pushes things. It pushes things of type `T` through a series of operators forming other `Observables`.  Each pushed item is known as an **emission**. Those emissions are pushed all the way to a `Subscriber` where they are finally consumed. 

You will need to create a **source Observable** where emissions originate from, and there are many factories to do this. To create a source `Observable` that pushes items 1 through 5, declare the following: 

**Java**

```java 
Observable<Integer> source = Observable.just(1,2,3,4,5);
```
**Kotlin**

```kotlin
val source = Observable.just(1,2,3,4,5)
```

This source `Observable<Integer>` is saved to a variable named `source`. However, it has not pushed anything yet. In order to start pushing emissions, you need to create a `Subscriber`. The quickest way to do this is call `subscribe()` and pass a lambda specifying what to do with each emission. 

**Java**

```java 
Observable<Integer> source = Observable.just(1,2,3,4,5);
source.subscribe(i -> System.out.println(i));
```
**Kotlin**

```kotlin
val source = Observable.just(1,2,3,4,5)
source.subscribe { println(it) }
```

A **lambda** is a special type of argument specifying an instruction. This one will take each emission and print it, and this `subscribe()` operation creates a `Subscriber`. 

>Java 8 and Kotlin have their own ways of expressing lambdas. If you need to learn more about Java 8 lambdas, I would recommend reading at least the first two chapters of [*Java 8 Lambdas*](http://shop.oreilly.com/product/0636920030713.do) by Richard Warburton before proceeding. You can read the [Kotlin Reference](https://kotlinlang.org/docs/reference/lambdas.html) to learn about lambdas in Kotlin. Lambdas are a very critical and concise syntax feature that we will use constantly in this book.

Go ahead and run the code above in a test or `main()` method, and you should get the following:

**OUTPUT:**
```
1
2
3
4
5
```

You can specify up to three lambda arguments on the `subscribe()` method to not only handle each emission, but also handle the event of an error as well as specify an action when there are no more emissions.

**Java**
```java
source.subscribe(i -> System.out.println(i),
                e -> e.printStackTrace(),
                () -> System.out.println("Done!")
        );
```

**Kotlin**
```kotlin
val source = Observable.just(1, 2, 3, 4, 5)

source.subscribeWith {
    onNext { println(it) }
    onError { it.printStackTrace() }
    onCompleted { println("Done!") }
}
```

**OUTPUT:**

```
1
2
3
4
5
Done!
```

Let's briefly break down the `Subscriber` to understand it better. The lambdas are just a shortcut to allow the `subscribe()` method to quickly create a `Subscriber` for you. You can create your own `Subscriber` object explicitly by extending and implementing its three abstract methods: `onNext()`, `onError()`, and `onCompleted()`.  You can then pass this `Subscriber` to the `subscribe()` method.

**Java**
```java
Observable<Integer> source = Observable.just(1,2,3,4,5);

Subscriber<Integer> subscriber = new Subscriber<Integer>() {
    @Override
    public void onCompleted() {
        System.out.println("Done!");
    }

    @Override
    public void onError(Throwable e) {
        e.printStackTrace();
    }

    @Override
    public void onNext(Integer integer) {
        System.out.println(integer);
    }
};

source.subscribe(subscriber);
```

**Kotlin**
```kotlin
val source = Observable.just(1, 2, 3, 4, 5)

val subscriber = object: Subscriber<Int>() {
    override fun onCompleted() = println("Done!")

    override fun onNext(t: Int) = println(t)

    override fun onError(e: Throwable) = e.printStackTrace()
}

source.subscribe(subscriber)
```


The `Subscriber`  actually implements the `Observer` interface which defines these three methods. The `onNext()` is what is called to pass an emission. The `onError()` is called when there is an error, and `onCompleted()` is called when there are no more emissions. Logically with infinite Observables, the `onCompleted()` is never called. 

> It is critical to note that the `onNext()` can only be called by one thread at a time. There should never be multiple threads calling `onNext()` concurrently. We will learn more about this later when we cover concurrency. For now just note RxJava has no notion of parallelization, and when you subscribe to a factory like `Observable.just(1,2,3,4,5)`, you will always get those emissions serially and in that exact order *on a single thread*. 

These three methods on the `Observer` are very critical for understanding RxJava, and we will revisit them continuously in this chapter. Although it is helpful for understanding the `Subscriber`, creating your own `Subscriber` objects can be pretty verbose, so it is helpful to use lambdas instead for conciseness. 

Going back to the source `Observable`, there are other factories to create them. Above we emitted the integers 1 through 5. Since these are consecutive, we can use `Observable.range()` to accomplish the same thing. It will emit the numbers 1 through 5 based on their range, and then call `onComplete()`. 

**Java**
```java
Observable<Integer> source = Observable.range(1,5);
```

**Kotlin**
```kotlin
val source = Observable.range(1,5)
```

You can also turn any `Collection` into an `Observable` quickly using `Observable.from()`. It will emit all items in that `Collection` and then call `onComplete()` when it is done. 

**Java**
```java
List<Integer> list = Arrays.asList(1,2,3,4,5);
Observable<Integer> source = Observable.from(list);
```

**Kotlin**
```kotlin
val list = listOf(1,2,3,4,5)
val source = Observable.from(list)
```

## Using Operators

Let's do something a little more useful than just connecting a source `Observable` and a `Subscriber`. Let's put some operators between them to actually intercept emissions and do work. 



### map()

Say you have an `Observable<String>` that pushes `String` values. 

**Java**
```java
Observable<String> source = 
    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon");
```

**Kotlin**
```kotlin
val source =  Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
```

In RxJava, you can use hundreds of operators to transform emissions and create new Observables with those transformations. For instance, you can create an `Observable<Integer>` off an `Observable<String>` by using the `map()` operator, and use it to emit each String's length. 

**Java**
```java
Observable<String> source = 
    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon");

Observable<Integer> lengths = source.map(s -> s.length());

lengths.subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
val source =  Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")

val lengths = source.map { it.length }

lengths.subscribe { println(it) }
```

**OUTPUT:**
```
5
4
5
5
7
```

The `source` Observable pushes each `String` to the `map()` operator where it is mapped to its `length()`. That length is then pushed from the `map()` operator to the `Subscriber` where it is printed. 

You can do all of this without any intermediary variables holding each `Observable`, and instead do everything in a single "chain" call. This can be done all in one line or broken up into multiple lines. 

**Java**
```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.map(s -> s.length())
	.subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.map { it.length }
	.subscribe { println(it) }
```

Operators behave as both an intermediary `Subscriber` and an `Observable`, subscribing to its left-hand neighbor  to get its emissions, and then turn around and pass those emissions to its right-hand neighbor.

```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon") // calls onNext() on map()
	.map(s -> s.length()) // calls onNext() on Subscriber
	.subscribe(i -> System.out.println(i));
```

### filter()

Another common operator is `filter()`, which suppresses emissions that fail to meet a certain criteria, and pushes the ones that do forward. For instance, you can emit only Strings where the `length()` is at least 5.  In this case, the `filter()` will stop "Beta" from proceeding since it is 4 characters.

**Java**
```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.filter(s -> s.length() >= 5)
	.subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.filter { it.length() >= 5 }
	.subscribe { println(it) }
```

**OUTPUT:**
```
Alpha
Gamma
Delta
Epsilon
```

### distinct()

There are also operators like `distinct()`, which will suppress emissions that have previously been emitted to prevent duplicate emissions (based on each emission's `hashcode()`/`equals()` implementation).  


**Java**
```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.map(s -> s.length())
	.distinct()
	.subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.map { it.length }
	.distinct()
	.subscribe { println(it) }
```

**OUTPUT:**

```
5
4
7
```

You can also provide a lambda specifying an attribute of each emission to distinct on, rather than the emission itself. 


**Java**
```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.distinct(s -> s.length())
	.subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.distinct { it.length }
	.subscribe { println(it) }
```

**OUTPUT:**

```
Alpha
Beta
Epsilon
```

### take()

The `take()` operator will cut off at a fixed number of emissions and then unsubscribe from the source. Afterwards, it will call `onCompleted()` down the rest of the chain. 


**Java**
```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.take(3)
	.subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.take(3)
	.subscribe { println(it) }
```

**OUTPUT:**

```
Alpha
Beta
Gamma
```

`takeWhile()` and `takeUntil()` do something similar to `take()`, but specify a lambda condition to determine when to stop taking emissions rather than using a fixed count. 

### count()

Some operators will aggregate the emissions in some form, and then push that aggregation as a single emission to the `Subscriber`. Obviously, this requires the `onCompleted()` to be called so that the aggregation can be finalized and pushed to the `Subscriber`. 

One of these aggregation operators is `count()`. It will simply count the number of emissions and when its `onCompleted()` is called, it will push the count up to the `Subscriber` as a single emission. Then it will call `onCompleted()` up to the `Subscriber`. 


**Java**
```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.count()
	.subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.count()
	.subscribe { println(it) }
```

**OUTPUT:**

```
5
```

### toList()

The `toList()` is similar to the `count()`. It will collect the emissions until its `onCompleted()` is called. After that it will push an entire `List` containing all the emissions to the `Subscriber`. 

**Java**
```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.toList()
	.subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
	.toList()
	.subscribe { println(it) }
```

**OUTPUT:**

```
[Alpha, Beta, Gamma, Delta, Epsilon]
```

Like using `count()`, the `toList()` will misbehave on infinite Observables because collections can only be finite, and it needs that `onCompleted()` to be called to push the `List` forward. Otherwise it will collect and work infinitely. 

###reduce() and scan()

When you need to do a custom aggregation, you can use `reduce()` to achieve this in most cases (to aggregate into collections, you can use its cousin `collect()`). But say we wanted the sum of all lengths for all emissions. Started with a seed value of zero, we can use a lambda specifying how to "fold" the emissions into a singel value. 

**Java**
```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
     .map(s -> s.length())
     .reduce(0,(l1,l2) -> l1 + l2)
     .subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
        .map { it.length }
        .reduce(0) { l1,l2 -> l1 + l2 }
        .subscribe { println(it) }
```

**OUTPUT:**

```
26
```

The lambda in `reduce()` will keep adding two `Integer` values (where one of them is the "rolling total" or seed `0` value, and the other is the new value to be added). As soon as `onCompleted()` is called, it will push the result to the `Subscriber`. 

The `reduce()` will push a single aggregated derived from all the emissions. If you want to push the "running total" for each emission, you can use `scan()` instead. This can work with infinite Observables since it will push each accumulation for each emission, rather than waiting for all emissions to be accumulated. 

**Java**
```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
     .map(s -> s.length())
	     .reducescan0,(l1,l2) -> l1 + l2)
     .subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
        .map { it.length }
        .scan(0) { l1,l2 -> l1 + l2 }
        .subscribe { println(it) }
```

**OUTPUT:**

```
0
5
9
14
19
26
```

### flatMap()

There are [hundreds of operators](http://reactivex.io/documentation/operators.html) in RxJava, but we will only cover one more for now. Throughout the book we will learn more as we go, and the most effective way to learn operators is to seek them out of need.

The `flatMap()` is similar to `map()`, but you map the emission to another set of emissions, via another `Observable`. This is one of the most powerful operators in RxJava and is full of use cases especially, but for now we will just stick with a simple example. 

Say we have some emissions where each one contains some concatenated numbers separated by a slash `/`. Say we wanted to break these numbers up into separate emissions (and omit the slashes). You can call `split()` on each `String` and  specify splitting it on the slash `/`, and this will return an array of the separated`String` values. Then  you can turn that array into an `Observable` inside the `flatMap()`. 

**Java**
```java
Observable.just("123/52/6345","23421/534","758/2341/74932")
		.flatMap(s -> Observable.from(s.split("/")))
		.subscribe(i -> System.out.println(i));
```

**Kotlin**
```kotlin
Observable.just("123/52/6345","23421/534","758/2341/74932")
         .flatMap { it.split(Regex("/")).toObservable() }
         .subscribe { println(it) }
```

**OUTPUT:**

```
123
52
6345
23421
534
758
2341
74932
```

If you observe this closely, hopefully you will  find the `flatMap()` is pretty straightforward, and it is. You are taking each emission and replacing it with another set of emissions, by providing another `Observable`. There is a lot of very powerful ways to leverage the `flatMap()`, especially when used with infinite and hot Observables (covered next). We will see it in many flavors throughout this book.

## Observables and Timing

If you are a somewhat experienced developer, you might be asking how is the `Observable` any different than a [Java 8 Stream](http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/) or [Kotlin Sequences](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/). Up to this point you are correct, they do not seem much different. But again, let's emphasize that Observables *push*, while Java 8 Streams and Kotlin Sequences *pull*. This enables RxJava to achieve much more and unleashes capabilities you might have never thought of. 

But the fundamental benefit of *pushing* is it allows a notion of *emissions over time*.  Our previous examples do not exactly show this, but we will dive into some examples that demonstrate this capability.

### Turning Button Events into an Observable

So far we just pushed data out of Observables. But did you know you can push events too? As a matter of fact, data and events are basically one in the same in RxJava. Let's take a simple JavaFX `Application` with a single `Button`. 

**Java**
```java
public final class MyApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();
        Button button = new Button("Press Me");

        vBox.getChildren().add(button);
        stage.setScene(new Scene(vBox));
        stage.show();
    }
}
```

**Kotlin**
```kotlin
class MyApp: App() {
    override val primaryView = MyView::class
}

class MyView: View() {
    override val root = vbox {
        button("Press Me")
    }
}
```

**Rendered UI:**

![](http://i.imgur.com/x1B5qzi.png)

We can use RxJavaFX or RxKotlinFX to create an `Observable<ActionEvent>` that pushes an `ActionEvent` emission each time the `Button` is pressed. 

**Java**
```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();
        Button button = new Button("Press Me");

        JavaFxObservable.fromActionEvents(button)
                .subscribe(ae -> System.out.println(ae));

        vBox.getChildren().add(button);
        stage.setScene(new Scene(vBox));
        stage.show();
    }
}

```

**Kotlin**
```kotlin
class MyApp: App() {
    override val primaryView = MyView::class
}

class MyView: View() {
    override val root = vbox {
        button("Press Me")
	        .actionEvents()
            .subscribe { println(it) }
    }
}
```

If you click the `Button` a couple times your console should look something like this: 

**OUTPUT:**
```
javafx.event.ActionEvent[source=Button@751b917f[styleClass=button]'Press Me']
javafx.event.ActionEvent[source=Button@751b917f[styleClass=button]'Press Me']
javafx.event.ActionEvent[source=Button@751b917f[styleClass=button]'Press Me']
```

Wait, did we seriously treat the `ActionEvent` as a piece of data and push it through the `Observable`? Yes we did! As said earlier, this is the powerful part of RxJava as it treats events and data in the same way. You can use all the operators we used earlier and apply them to events. For example, we can use `scan()` to push how many times the `Button` was pressed, and push that in a `Label`.  Just `map()` each `ActionEvent` to a `1` to drive an increment first. 

**Java**
```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();
        Button button = new Button("Press Me");
        Label countLabel = new Label("0");

        JavaFxObservable.fromActionEvents(button)
                .map(ae -> 1)
                .scan(0,(x,y) -> x + y)
                .subscribe(clickCount -> countLabel.setText(clickCount.toString()));

        vBox.getChildren().add(countLabel);
        vBox.getChildren().add(button);

        stage.setScene(new Scene(vBox));
        stage.show();
    }
}
```

**Kotlin**
```
class MyApp: App() {
    override val primaryView = MyView::class
}

class MyView: View() {

    override val root = vbox {

        val countLabel = label("0")

        button("Press Me")
                .actionEvents()
                .map { 1 }
                .scan(0) {x,y -> x + y }
                .subscribe { countLabel.text = it.toString() }
    }
}

```

**RENERED UI:** After I clicked the button 5 times

![](http://i.imgur.com/n7swqnB.png)

So how does all this work? Well, the `Observable<ActionEvent>` we created off this `Button` is emitting `ActionEvent` items over time. In this case, the timing of each emission depends completely on when the `Button` is clicked. Every time that `Button` is clicked, it pushes an `ActionEvent` item through the `Observable`.  There is no notion of completion as this `Observable` is always alive during the life of the `Button`. 