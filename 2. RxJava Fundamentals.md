# 2. RxJava Fundamentals

RxJava has two core types: the `Observable` and the `Observer`. In the simplest definition, an `Observable` *pushes* things. A given `Observable<T>` will push items of type `T` through a series of operators that form other Observables, and finally the terminal `Observer` is what consumes the items at the end of the chain.

Each pushed `T` item is known as an **emission**. Usually there is a finite number of emissions, but sometimes there can be infinite. An emission can represent either data or an event (or both!). This is where the power of reactive programming differentiates itself from Java 8 Streams and Kotlin Sequences. It has a notion of *emissions over time*, and we will explore this concept in this chapter.


## The `Observable` and `Observer`

As stated earlier, an **Observable** pushes things. It pushes things of type `T` through a series of operators forming other `Observables`.  Each pushed item is known as an **emission**. Those emissions are pushed all the way to a `Observer` where they are finally consumed.

You will need to create a **source Observable** where emissions originate from, and there are many factories to do this. To create a source `Observable` that pushes items 1 through 5, declare the following:

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable<Integer> source = Observable.just(1,2,3,4,5);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {
    val source = Observable.just(1,2,3,4,5)
}
```

This source `Observable<Integer>` is saved to a variable named `source`. However, it has not pushed anything yet. In order to start pushing emissions, you need to create an `Observer`. The quickest way to do this is call `subscribe()` and pass a lambda specifying what to do with each emission.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable<Integer> source = Observable.just(1,2,3,4,5);

        source.subscribe(System.out::println);
    }
}
```
**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    val source = Observable.just(1,2,3,4,5)
    source.subscribe(::println)
}
```

A **lambda** is a special type of argument specifying an action. This one will take each emission and print it, and this `subscribe()` operation creates a `Observer` for us based on this lambda argument.

>Java 8 and Kotlin have their own ways of expressing lambdas. If you need to learn more about Java 8 lambdas, I would recommend reading at least the first two chapters of [*Java 8 Lambdas*](http://shop.oreilly.com/product/0636920030713.do) by Richard Warburton before proceeding. You can read the [Kotlin Reference](https://kotlinlang.org/docs/reference/lambdas.html) to learn about lambdas in Kotlin. Lambdas are a critical syntax feature that we will use constantly in this book.

Go ahead and run the code above, and you should get the following:

**OUTPUT:**
```
1
2
3
4
5
```

This effectively pushed the integers 1 through 5, one-at-a-time, to the `Observer` defined by the lambda in the `subscribe()` method. The `subscribe()` method does not have to print items. It could populate them in a JavaFX control, write them to a database, or post it as a server response.

### Understandings Observers

You can specify up to three lambda arguments on the `subscribe()` method to not only handle each emission, but also handle the event of an error as well as an action on completion when there are no more emissions.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable<Integer> source = Observable.just(1,2,3,4,5);

        source.subscribe(System.out::println,
                Throwable::printStackTrace,
                () -> System.out.println("Done!")
        );
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable
import rx.lang.kotlin.subscribeBy

fun main(args: Array<String>) {

    val source = Observable.just(1, 2, 3, 4, 5)

    source.subscribeBy(
        onNext = ::println,
        onError = { it.printStackTrace() },
        onComplete = { println("Done!") }
    )
}
```

**OUTPUT:**

```
1
2
3
4
5
Done!
```

>Typically, you should always supply an `onError` lambda to your `subscribe()` call so errors do not quietly go unhandled. We will not use `onError` very much in this book for the sake of brevity, but be sure to use it when putting reactive code in production.

Let's briefly break down the `Observer` to understand it better. The lambdas are just a shortcut to allow the `subscribe()` method to quickly create an `Observer` for you. You can create your own `Observer` object explicitly by extending `ResourceObserver` and implementing its three abstract methods: `onNext()`, `onError()`, and `onComplete()`.  You can then pass this `Observer` to the `subscribe()` method.

**Java**

```java
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.observers.ResourceObserver;

public class Launcher {

    public static void main(String[] args) {

        Observable<Integer> source = Observable.just(1,2,3,4,5);

        Observer<Integer> subscriber = new ResourceObserver<Integer>() {
            @Override
            public void onComplete() {
                System.out.println("Done!");
            }

            @Override
            public void onError(Throwable e) {
                e.printStackTrace();
            }

            @Override
            public void onNext(Integer integer) {
                System.out.println(integer);
            }
        };

        source.subscribe(subscriber);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable
import io.reactivex.observers.ResourceObserver

fun main(args: Array<String>) {
    val source = Observable.just(1, 2, 3, 4, 5)

    val subscriber = object: ResourceObserver<Int>() {
        override fun onComplete() = println("Done!")

        override fun onNext(i: Int) = println(i)

        override fun onError(e: Throwable) = e.printStackTrace()
    }

    source.subscribe(subscriber)

}
```


The `Observer` interface defines these three methods. The `onNext()` is what is called to pass an emission. The `onError()` is called when there is an error, and `onComplete()` is called when there are no more emissions. Logically with infinite Observables, the `onComplete()` is never called.

> We extend a `ResourceObserver` because the `Observer` actually has a fourth abstract method, `onSubscribe()`. This is something you will rarely need to implement yourself, and `ResourceObserver` will take care of it for you. Essentially, the `onSubscribe()` allows the `Observer` implementation to have control of the `Disposable` which is beyond the scope of this book. We will touch on the `Dispsoable` later, but you can learn much more about it in Chapter 2 of my book [Learning RxJava](https://www.packtpub.com/application-development/learning-rxjava) by Packt Publishing.

Although this example is helpful for understanding the `Observer`, it also shows implementing `Observer` objects can be pretty verbose. Therefore, it is helpful to use lambdas instead for conciseness. These three methods on the `Observer` are critical for understanding RxJava, and we will revisit them several times in this chapter.

> It is critical to note that the `onNext()` can only be called by one thread at a time. There should never be multiple threads calling `onNext()` concurrently, and we will learn more about this later when we cover concurrency. For now just note RxJava has no notion of parallelization, and when you subscribe to a factory like `Observable.just(1,2,3,4,5)`, you will always get those emissions serially, in that exact order, and *on a single thread*.


## Source Observable Factories


Going back to the `Observable`, there are other factories to create source Observables. Above we emitted the integers 1 through 5. Since these are consecutive, we can use `Observable.range()` to accomplish the same thing. It will emit the numbers 1 through 5 based on their range, and then call `onComplete()`.

Note these examples have no subscribers, so there will be no output when running them.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable<Integer> source = Observable.range(1,5);
    }
});
```

**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    val source = Observable.range(1,5)
}
```

You can also turn any `Iterable<T>` into an `Observable<T>` quickly using `Observable.fromIterable()`. It will emit all items in that `Iterable<T>` and then call `onComplete()` when it is done.

**Java**

```java
import io.reactivex.Observable;
import java.util.Arrays;
import java.util.List;

public class Launcher {

    public static void main(String[] args) {

        List<Integer> list = Arrays.asList(1,2,3,4,5);
        Observable<Integer> source = Observable.fromIterable(list);    }
}
```

**Kotlin**

```kotlin
import io.reactivex.rxkotlin.toObservable

fun main(args: Array<String>) {

    val list = listOf(1,2,3,4,5)
    val source = list.toObservable()
}
```

## Using Operators

Let us do something a little more useful than just connecting a source `Observable` and an `Observer`. Let's put some operators between them to actually transform emissions and do work.

### map()

Say you have an `Observable<String>` that pushes `String` values.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable<String> source =
                Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon");
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    val source = Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")

}
```

In RxJava, you can use hundreds of operators to transform emissions and create new Observables with those transformations. For instance, you can create an `Observable<Integer>` off an `Observable<String>` by using the `map()` operator, and use it to emit each String's length.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable<String> source =
                Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon");

        Observable<Integer> lengths = source.map(String::length);

        lengths.subscribe(System.out::println);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    val source =  Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")

    val lengths = source.map { it.length }

    lengths.subscribe(::println)
}
```

**OUTPUT:**
```
5
4
5
5
7
```

The `source` Observable pushes each `String` to the `map()` operator where it is mapped to its `length`. That length is then pushed from the `map()` operator to the `Observer` where it is printed.

You can do all of this without any intermediary variables holding each `Observable`, and instead do everything in a single "chain" call. This can be done in one line or broken up into multiple lines.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {
        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
                .map(String::length)
                .subscribe(System.out::println);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
            .map { it.length }
            .subscribe(::println)
}
```

Operators behave as both an intermediary `Observer` and an `Observable`, receiving emissions from the upstream source, transforming them, and passing them downstream to the final `Observer`.

```java
Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon") // calls onNext() on map()
	.map(s -> s.length()) // calls onNext() on Observer
	.subscribe(i -> System.out.println(i));
```

### filter()

Another common operator is `filter()`, which suppresses emissions that fail to meet a certain criteria, and pushes the ones that do forward. For instance, you can emit only Strings where the `length()` is at least 5.  In this case, the `filter()` will stop "Beta" from proceeding since it is 4 characters.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {
        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
                .filter(s -> s.length() >= 5)
                .subscribe(System.out::println);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")
            .filter { it.length >= 5 }
            .subscribe(::println)
}
```

**OUTPUT:**
```
Alpha
Gamma
Delta
Epsilon
```

### distinct()

There are also operators like `distinct()`, which will suppress emissions that have previously been emitted to prevent duplicate emissions (based on each emission's `hashcode()`/`equals()` implementation).


**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {
        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
                .map(String::length)
                .distinct()
                .subscribe(System.out::println);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")
            .map { it.length }
            .distinct()
            .subscribe(::println)
}
```

**OUTPUT:**

```
5
4
7
```

You can also provide a lambda specifying an attribute of each emitted item to distinct on, rather than the item itself.


**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {
        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
                .distinct(String::length)
                .subscribe(System.out::println);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
            .distinct { it.length }
            .subscribe(::println)
}
```

**OUTPUT:**

```
Alpha
Beta
Epsilon
```

### take()

The `take()` operator will cut off at a fixed number of emissions and then unsubscribe from the source. Afterwards, it will call `onComplete()` downstream to the final `Observer`.


**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {
        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
                .take(3)
                .subscribe(System.out::println);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
            .take(3)
            .subscribe(::println)
}
```

**OUTPUT:**

```
Alpha
Beta
Gamma
```

`takeWhile()` will do something similar to `take()`, but specifies a lambda condition to determine when to stop taking emissions rather than using a fixed count.


**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {
        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
                .takeUntil((String s) -> s.matches("D.*"))
                .subscribe(System.out::println);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
            .takeUntil { it.startsWith("D" )}
            .subscribe(::println)
}
```

**OUTPUT:**

```
Alpha
Beta
Gamma
Delta
```


### count()

Some operators will aggregate the emissions in some form (in a classic [MapReduce](https://en.wikipedia.org/wiki/MapReduce) fashion), and then push that aggregation as a single emission to the `Observer`. Obviously, this requires the `onComplete()` to be called so that the aggregation can be finalized and pushed to the `Observer`.

One of these aggregation operators is `count()`. It will simply count the number of emissions and when its `onComplete()` is called, and push the count up to the `Observer` as a single emission. Then it will call `onComplete()` up to the `Observer`.


**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
                .count()
                .subscribe(System.out::println);
    }
}));
```

**Kotlin**

```kotlin
import io.reactivex.Observable
import io.reactivex.rxkotlin.subscribeBy

fun main(args: Array<String>) {

    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
            .count()
            .subscribeBy { println(it) }
}
```

**OUTPUT:**

```
5
```

The `count()` actually returns a `Single`, which is a specialized `Observable` type that only emits one item. The `Single` does not have an `onNext` or `onComplete`, but rather an `onSuccess` event which passes the single item. If you ever need to turn a `Single` back into an `Observable` (so it works with certain `Observable` operators), just call its `toObservable()` method.

> Another variant of `Observable` we will encounter is the `Maybe`, which emits 0 or 1 values. There is also the `Completable` which ignores emissions but we will not be using it in this book.


### toList()

The `toList()` is similar to the `count()`, and it also will yield a `Single` rather than an `Observable`. It will collect the emissions until its `onComplete()` is called. After that it will push an entire `List` containing all the emissions to the `Observer`.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
                .toList()
                .subscribe(System.out::println);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable
import io.reactivex.rxkotlin.subscribeBy

fun main(args: Array<String>) {

    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
            .toList()
            .subscribeBy { println(it) }
}
```

**OUTPUT:**

```
[Alpha, Beta, Gamma, Delta, Epsilon]
```

Aggregate operators like `toList()` will misbehave on infinite Observables because collections can only be finite, and it needs that `onComplete()` to be called to push the `List` forward. Otherwise it will collect and work infinitely.

> When using Singles in Kotlin, we use RxKotlin's `subscribeBy()` instead of `subscribe()` because there is an inference bug with the Kotlin compiler working with SAM types. Hopefully this will be fixed soon by JetBrains. You can [follow the filed issue here](https://youtrack.jetbrains.com/issue/KT-13609) to track its status.

### reduce()

When you need to do a custom aggregation or reduction, you can use `reduce()` to achieve this in most cases (to aggregate into collections and other mutable structures, you can use its cousin `collect()`). This will return a `Single` (if a "seed" value is provided) or a `Maybe` (if no "seed" value is provided). But say we wanted the sum of all lengths for all emissions. Starting with a seed value of zero, we can use a lambda specifying how to "fold" the emissions into a single value.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
                .map(String::length)
                .reduce(0,(current,next) -> current + next)
                .subscribe(System.out::println);
    }
}
```

**Kotlin**

```kotlin
import io.reactivex.Observable
import io.reactivex.rxkotlin.subscribeBy

fun main(args: Array<String>) {

    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
            .map { it.length }
            .reduce(0) { current,next -> current + next }
            .subscribeBy { println(it) }
}
```

**OUTPUT:**

```
26
```

The lambda in `reduce()` will keep adding two `Integer` values, where one of them is the "rolling total" (`current`) or seed `0` value, and the other is the new value (`next`) to be added. As soon as `onComplete()` is called, it will push the result to the `Observer`.

### scan()

The `reduce()` will push a single aggregated value derived from all the emissions. If you want to push the "running total" for each emission, you can use `scan()` instead. This can work with infinite Observables since it will push each accumulation for each emission, rather than waiting for all emissions to be accumulated.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
                .map(String::length)
                .reduce(0,(current,next) -> current + next)
                .subscribe(System.out::println);
    }
}

```
```kotlin
import io.reactivex.Observable

fun main(args: Array<String>) {

    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
            .map { it.length }
            .reduce(0) { current,next -> current + next }
            .subscribe(::println)
}
```

**OUTPUT:**

```
0
5
9
14
19
26
```

### flatMap()

There are [hundreds of operators](http://reactivex.io/documentation/operators.html) in RxJava, but we will only cover one more for now. Throughout the book we will learn more as we go, and the most effective way to learn operators is to seek them out of need.

The `flatMap()` is similar to `map()`, but will map the emission to another set of emissions via another `Observable`. This is one of the most powerful operators in RxJava and is full of use cases, but for now we will just stick with a simple example.

Say we have some `String` emissions where each one contains concatenated numbers separated by a slash `/`. We want to break up these numbers into separate emissions (and omit the slashes). You can call `split()` on each `String` and  specify splitting on the slashes `/`, and this will return an array of the separated `String` values. Then you can turn that array into an `Observable` inside the `flatMap()`.

**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable.just("123/52/6345","23421/534","758/2341/74932")
                .flatMap(s -> Observable.fromArray(s.split("/")))
                .subscribe(System.out::println);
    }
}

```

**Kotlin**

```kotlin
import io.reactivex.Observable
import io.reactivex.rxkotlin.toObservable

fun main(args: Array<String>) {

    Observable.just("123/52/6345","23421/534","758/2341/74932")
            .flatMap { it.split("/").toObservable() }
            .subscribe(::println)
}
```

**OUTPUT:**

```
123
52
6345
23421
534
758
2341
74932
```

If you observe this closely, hopefully you will find the `flatMap()` is pretty straightforward. You are taking each emission and replacing it with another set of emissions, by providing another `Observable` derived off that emission. There is a lot of very powerful ways to leverage the `flatMap()`, especially when used with infinite, concurrent, and hot Observables which we will cover later.


Also note that `flatMapSingle()` can be used to `flatMap()` to a `Single`, and `flatMapMaybe()` to a `Maybe`. This saves you the step of having to call `toObservable()` on each resulting `Maybe` or `Single`. If we wanted to sum each set of numbers, we would do it like this since this `reduce()` will yield a `Single`.


**Java**

```java
import io.reactivex.Observable;

public class Launcher {

    public static void main(String[] args) {

        Observable.just("123/52/6345","23421/534","758/2341/74932")
                .flatMapSingle(s ->
                        Observable.fromArray(s.split("/"))
                        .map(Integer::valueOf)
                        .reduce(0, (curr,next) -> curr + next)
                )
                .subscribe(System.out::println);
    }
}
```

**Kotlin**


```kotlin
import io.reactivex.Observable
import io.reactivex.rxkotlin.toObservable

fun main(args: Array<String>) {

    Observable.just("123/52/6345","23421/534","758/2341/74932")
            .flatMapSingle {
                it.split("/").toObservable()
                        .map { it.toInt() }
                        .reduce(0) { curr, next -> curr + next }
            }
            .subscribe(::println)
}
```


**OUTPUT:**

```
6520
23955
78031
```


## Observables and Timing

If you are a somewhat experienced developer, you might be asking how is the `Observable` any different than a [Java 8 Stream](http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/) or [Sequences](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/) in Kotlin, C#, or Scala. Up to this point you are correct, they do not seem much different. But recall that Observables *push*, while Java 8 Streams and Sequences *pull*. This enables RxJava to achieve much more and unleashes capabilities that these other functional utilities do not offer.

But the fundamental benefit of *pushing* is it allows a notion of *emissions over time*.  Our previous examples do not exactly show this, but now we will dive into some examples that do.

### Making Button Click Events an Observable

So far we just pushed data out of Observables. But did you know you can push events too? As stated earlier, data and events are basically the same thing in RxJava. Let's take a simple JavaFX `Application` with a single `Button`.

**Java**
```java
public final class MyApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();
        Button button = new Button("Press Me");

        vBox.getChildren().add(button);
        stage.setScene(new Scene(vBox));
        stage.show();
    }
}
```

**Kotlin**
```kotlin
class MyApp: App(MyView::class)

class MyView: View() {
    override val root = vbox {
        button("Press Me")
    }
}
```

**Rendered UI:**

![](http://i.imgur.com/x1B5qzi.png)

We can use RxJavaFX or RxKotlinFX to create an `Observable<ActionEvent>` that pushes an `ActionEvent` emission each time the `Button` is pressed.

**Java**
```java
public final class MyApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();
        Button button = new Button("Press Me");

        JavaFxObservable.actionEventsOf(button)
                .subscribe(ae -> System.out.println(ae));

        vBox.getChildren().add(button);
        stage.setScene(new Scene(vBox));
        stage.show();
    }
}

```

**Kotlin**
```kotlin
class MyApp: App(MyView::class)

class MyView: View() {
    override val root = vbox {
        button("Press Me")
	        .actionEvents()
          .subscribe { println(it) }
    }
}
```

If you click the `Button` a couple times your console should look something like this:

**OUTPUT:**
```
javafx.event.ActionEvent[source=Button@751b917f[styleClass=button]'Press Me']
javafx.event.ActionEvent[source=Button@751b917f[styleClass=button]'Press Me']
javafx.event.ActionEvent[source=Button@751b917f[styleClass=button]'Press Me']
```

Wait, did we just treat the `ActionEvent` like any other emission and push it through the `Observable`? Yes we did! As said earlier, this is the powerful part of RxJava. It treats events and data the same way, and you can use all the operators we covered earlier. For example, we can use `scan()` to push how many times the `Button` was pressed, and push that into a `Label`.  Just `map()` each `ActionEvent` to a `1` to drive increments.

**Java**
```java
public final class MyApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();
        Button button = new Button("Press Me");
        Label countLabel = new Label("0");

        JavaFxObservable.actionEventsOf(button)
                .map(ae -> 1)
                .scan(0,(x,y) -> x + y)
                .subscribe(clickCount -> countLabel.setText(clickCount.toString()));

        vBox.getChildren().add(countLabel);
        vBox.getChildren().add(button);

        stage.setScene(new Scene(vBox));
        stage.show();
    }
}
```

**Kotlin**
```kotlin
class MyApp: App(MyView::class)

class MyView: View() {

    override val root = vbox {

        val countLabel = label("0")

        button("Press Me")
                .actionEvents()
                .map { 1 }
                .scan(0) {x,y -> x + y }
                .subscribe { countLabel.text = it.toString() }
    }
}

```

**RENERED UI:** After I clicked the button 4 times

![](http://i.imgur.com/n7swqnB.png)

So how does all this work? The `Observable<ActionEvent>` we created off this `Button` is emitting an `ActionEvent` item every time the `Button` is pressed. Every time that `Button` is clicked, it pushes an `ActionEvent` emission through the `Observable`.  There is no notion of completion either as this `Observable` is always alive during the life of the `Button`.

Of course you could use operators that make the operation finite, like `take()`. If you only take 5 `ActionEvent` emissions from the `Button`, it will stop pushing on emission  `4`. Then it will unsubscribe from the source and call `onComplete()` down the chain to the `Observer`.

**Java**
```java
public final class MyApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();
        Button button = new Button("Press Me");
        Label countLabel = new Label("0");
        Label doneLabel = new Label("");

        JavaFxObservable.actionEventsOf(button)
                .map(ae -> 1)
                .scan(0,(x,y) -> x + y)
                .take(5)
                .subscribe(
                        clickCount -> countLabel.setText(clickCount.toString()),
                        e -> e.printStackTrace(),
                        () -> doneLabel.setText("Done!")
                        );

        vBox.getChildren().addAll(countLabel, doneLabel,button);

        stage.setScene(new Scene(vBox));
        stage.show();
    }
}
```
**Kotlin**
```kotlin
class MyApp: App(MyView::class)

class MyView: View() {

    override val root = vbox {

        val countLabel = label("0")
        val doneLabel = label("")

        button("Press Me")
                .actionEvents()
                .map { 1 }
                .scan(0) {x,y -> x + y }
                .take(5)
                .subscribeWith {
                    onNext { countLabel.text = it.toString() }
                    onError { it.printStackTrace() }
                    onCompleted { doneLabel.text = "Done!" }
                }
    }
}
```

**RENDERED UI:** After 4 `Button` clicks (emits an initial 0 from `scan()`)

![](http://i.imgur.com/LtHtPWS.png)

A `Button` emitting an `ActionEvent` item every time it is clicked is an example of a hot `Observable`, as opposed to cold Observables which typically push data. Let's dive into this discussion next.

### Cold vs. Hot Observables

The `Observable<ActionEvent>` we created off a `Button` is an example of a hot `Observable`. Earlier in this chapter, all of our examples emitting `Integer` and `String` items are cold Observables. So what is the difference?

Remember this source `Observable` that simply pushes five `String` emissions?

**Java**
```java
Observable<String> source =
    Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon");
```

**Kotlin**
```kotlin
val source = Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")
```


What do you think will happen if we `subscribe()` to it twice?  Try it out.

**Java**

```java
Observable<String> source =
        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon");

source.subscribe(s -> System.out.println("Observer 1: " + s));
source.subscribe(s -> System.out.println("Observer 2: " +s));
```

```kotlin
val source = Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon")

source.subscribe { println("Observer 1: $it") }
source.subscribe { println("Observer 2: $it") }
```

You will find the emissions are *replayed* for each `Observer`.

**OUTPUT:**
```
Observer 1: Alpha
Observer 1: Beta
Observer 1: Gamma
Observer 1: Delta
Observer 1: Epsilon
Observer 2: Alpha
Observer 2: Beta
Observer 2: Gamma
Observer 2: Delta
Observer 2: Epsilon
```
With a **Cold Observable**, every `Observer` independently receives all the emissions regardless of when they `Subscribe`. There is no notion of timing making an impact to which emissions they receive. Cold Observables are often used to "play" data independently to each `Observer`. This is like giving every `Observer` a music CD to play, and they can independently play all the tracks.

**Hot Observables**, however,  will simultaneously push emissions to all Observers at the same time. Logically, an effect of this is Observers that come later and have missed previous emissions will not receive them. They will only get emissions going forward from the time they `subscribe()`.  Instead of a music CD, Hot Observables are more like radio stations. They will broadcast a given song (emission) to all listeners (Observers) at the same time. If a listener misses a song, they missed it.

While data and events are the same in RxJava, Hot Observables are often used to represent events, such as an `Observable<ActionEvent>` built off a `Button`.

Let's do an experiment to see if tardy Observers indeed miss previous emissions. `subscribe()`  immediately to a`Button`'s clicks to create the first `Observer`. But have another `Button` that when clicked, will `subscribe()` a second `Observer`.

**Java**
```java
import io.reactivex.Observable;
import io.reactivex.rxjavafx.observables.JavaFxObservable;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public final class MyApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();
        Button button = new Button("Press Me");
        Button secondSubButton = new Button("Subscribe Observer 2");

        Observable<ActionEvent> clicks =
            JavaFxObservable.actionEventsOf(button);

        //Observer 1
        clicks.subscribe(ae ->
            System.out.println("Observer 1 Received Click!"));

        //Subscribe Observer 2 when secondSubButton is clicked
        secondSubButton.setOnAction(event -> {
                System.out.println("Observer 2 subscribing!");
                secondSubButton.disableProperty().set(true);
                //Observer 2
                clicks.subscribe(ae ->
                    System.out.println("Observer 2 Received Click!")
                );
            });

        vBox.getChildren().addAll(button,secondSubButton);

        stage.setScene(new Scene(vBox));
        stage.show();
    }
}
```
**Kotlin**

```kotlin
import com.github.thomasnield.rxkotlinfx.actionEvents
import tornadofx.*

class MyApp: App(MyView::class)

class MyView: View() {

    override val root = vbox {

        val clicks = button("Press Me").actionEvents()

        //Observer 1
        clicks.subscribe { println("Observer 1 Received Click!") }

        //Subscribe Observer 2 when this button is clicked
        button("Subscribe Observer 2") {
            setOnAction {
                println("Observer 2 subscribing!")
                isDisable = true
                clicks.subscribe { println("Observer 2 Received Click!") }
            }
        }
    }
}
```

**RENDERED UI:**

![](http://i.imgur.com/D0FsDK8.png)

Click the "Press Me" `Button` 3 times, then click the "Subscribe Observer 2" `Button`. Finally click "Press Me" 2 more times, and you should get this output in your console.

```
Observer 1 Received Click!
Observer 1 Received Click!
Observer 1 Received Click!
Observer 2 subscribing!
Observer 1 Received Click!
Observer 2 Received Click!
Observer 1 Received Click!
Observer 2 Received Click!
```

Notice that `Observer 1` received those first three clicks, and then we subscribed `Observer 2`. But notice that `Observer 2` has missed those first three clicks. It will never get them because it subscribed too late to a hot Observable. The only emissions `Observer 2` receives are the ones that happen after it subscribes.

After `Observer 2` is subscribed, you can see the last two emissions were pushed simultaneously to both `Observer 1` and `Observer 2`.

Again, Cold Observables will replay emissions to each `Observer` independently. Hot Observables play emissions all at once to whomever is subscribed, and it will not replay missed emissions to tardy Observers.

## ConnectableObservable

We will learn several ways to create hot Observables in this book for different tasks, but one that is worth mentioning now is the `ConnectableObservable`. Among a few other subtle behaviors it creates, it can turn a cold `Observable` into a hot one by forcing its emissions to become hot. To create one, you can take any `Observable` and call its `publish()` method. You can then set up the Observers and then call `connect()` to start firing the emissions.

One reason you may do this is because it might be expensive to replay emissions for each `Observer`, especially if it is emitting items from a slow database query or some other intensive operation. Notice too that each emission interleaves and goes to each `Observer` simultaneously.


**Java**
```java
ConnectableObservable<String> source =
        Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon").publish();

source.subscribe(s -> System.out.println("Observer 1: " + s));
source.subscribe(s -> System.out.println("Observer 2: " +s));

source.connect();
```

**Kotlin**
```kotlin
fun main(args: Array<String>) {
    val source = Observable.just("Alpha","Beta","Gamma","Delta", "Epsilon").publish()

    source.subscribe { println("Observer 1: $it") }
    source.subscribe { println("Observer 2: $it") }

    source.connect()
}
```

**OUTPUT:**
```
Observer 1: Alpha
Observer 2: Alpha
Observer 1: Beta
Observer 2: Beta
Observer 1: Gamma
Observer 2: Gamma
Observer 1: Delta
Observer 2: Delta
Observer 1: Epsilon
Observer 2: Epsilon
```

Remember though that the `ConnectableObservable` is a hot `Observable` too, so you got to be careful when pushing data through it. If any `Observer` comes in *after* the `connect()` is called, there is a good chance it will miss data that was emitted previously.

##Unsubscribing

There is one last operation we need to cover: unsubscribing. Subscription should happen automatically for finite Observables. But for infinite or long-running Observables, there will be times you want to stop the emissions and cancel the entire operation. This will also free up resources in the `Observable` chain and cause it to clean up any resources it was using.

If you want to disconnect a `Observer` from an `Observable`  so it stops receiving emissions, there are a couple ways to do this. The easiest way is to note the `subscribe()` method returns a `Subscription` object (not to be confused with the `Observer`). This represents the connection between the `Observable` and the `Observer`, and you can call `unsubscribe()` on it at any time to dispose the connections so no more emissions are pushed.

For instance, let's take our incrementing `Button` example from earlier and add another `Button` that will unsubscribe the emissions. We need to save the `Subscription` returned from the `subscribe()` method, and then we can refer to it later to call `unsubscribe()` and stop emissions.

**Java**
```java

public final class MyApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox vBox = new VBox();
        Button button = new Button("Press Me");
        Button unsubscribeButton = new Button("Unsubscribe");

        Label countLabel = new Label("0");

        Subscription subscription = JavaFxObservable.actionEventsOf(button)
                .map(ae -> 1)
                .scan(0,(x,y) -> x + y)
                .subscribe(clickCount -> countLabel.setText(clickCount.toString()));

        unsubscribeButton.setOnAction(e -> subscription.unsubscribe());


        vBox.getChildren().addAll(button,unsubscribeButton,countLabel);
        stage.setScene(new Scene(vBox));
        stage.show();
    }
}
```

**Kotlin**
```kotlin
class MyApp: App(MyView::class)

class MyView: View() {

    override val root = vbox {

        val countLabel = label("0")

        val subscription = button("Press Me")
                .actionEvents()
                .map { 1 }
                .scan(0) {x,y -> x + y }
                .subscribe { countLabel.text = it.toString() }


        button("Unsubscribe").setOnAction {
            subscription.unsubscribe()
        }
    }
}
```

Note that when you press the "Unsubscribe" `Button`, the increments stop because the `Observer` was unsubscribed, and it instructed the `Observable` to stop sending emissions. Unsubscription automatically happens with finite Observables once `onComplete()` is called. But with infinite or long-running Observables, you need to manage their unsubscription if you intend to dispose them at some point.

When you have infinite Observables that need to be disposed, it is *very* critical to call `unsubscribe()` on any Subscriptions when you are done with them. If you do not do this, you will run into memory leak problems and the garbage collector will not be able to free those resources.

When you have a lot of Subscriptions to manage and you want to dispose them all at once, you can use a `CompositeSubscription` which acts as a collection of Subscriptions. You can add any number of Subscriptions to it, and when you want to unsubscribe all of them just call its `unsubscribe()` method.

**java**
```java
Observable<ActionEvent> buttonClicks = ...

CompositeSubscription subscriptions = new CompositeSubscription();

Subscription subscription1 =
    buttonclicks.subscribe(ae -> System.out.println("Clicked!"));

subscriptions.add(subscription1);

Subscription subscription2 =
    buttonclicks.subscribe(ae -> System.out.println("Clicked Here Too!"));

subscriptions.add(subscription2);

//work with UI, then dispose when done
subscriptions.unsubscribe();
```

**Kotlin**
```kotlin
val buttonClicks: Observable<ActionEvent> = ...
val subscriptions = CompositeSubscription()

buttonclicks.subscribe { println("Clicked!") }
    .addto(subscriptions)

buttonclicks.subscribe { println("Clicked Here Too!") }
    .addto(subscriptions)

//work with UI, then dispose when done
subscriptions.unsubscribe()
```

### Using doOnXXX() Operators

It might be helpful to create a few "side effects" in the middle of an `Observable` chain. In other words, we want to put Observers in the middle of the chain at certain points. For instance, it might be helpful to change a "Submit" Button's text to "WORKING" when a request is being processed, as well as disable it so no more requests can be sent until the current one completes.

RxJava has `doOnXXX()` operators that allow you to "peek" into an `Observable` at that point in the chain. For instance, you can use `doOnNext()` and pass a lambda to do something with each emission, like print it. `doOnCompleted()` will fire a specified action when that point of the chain received a completion notification, and `doOnError()` will do the same for an error event. Here is a complete list of these `doOnXXX()` operators in RxJava.

|Operator|Example|Description|
|---|---|---|
|doOnNext()|doOnNext(i -> System.out.println(i))|Performs an action for each emission|
|doOnCompleted()|doOnCompleted(() -> System.out.println("Done!"))|Performs an action on completion|
|doOnError()|doOnError(e -> e.printStackTrace())|Performs an action on an error|
|doOnSubscribe()|doOnSubscribe(() -> System.out.println("Subbing!"))|Performs an action on subscription|
|doOnUnsubscribe()|doOnUnsubscribe(() -> System.out.println("Unsubbing!"))|Performs an action on unsubscription|
|doOnTerminate()|doOnTerminated(() -> System.out.println("I'm done or had an error"))|Performs an action for completion or an error|

#Summary

In this chapter we covered some RxJava fundamentals. The `Observable` treats data and events in the same way, and this is a powerful idea that applies really well with JavaFX. Cold Observables replay emissions to each `Observer` independently. Hot Observables will broadcast emissions live to all Observers simultaneously, and not replay missed emissions to tardy Observers.

This book will continue to cover RxJava and apply it in a JavaFX context. There are hundreds of operators and unfortunately we will not be able to cover them all, but we will focus on the ones that are especially helpful for building JavaFX applications. But if you want to learn more about RxJava itself outside of the JavaFX domain, check out [Learning Reactive Programming with Java 8](https://amzn.com/1785288725) (Nickolay Tsvetinov).

In the next chapter, we are going to dive a little deeper into JavaFX events, and turn `Node` and `ObservableValue` events into Observables.
