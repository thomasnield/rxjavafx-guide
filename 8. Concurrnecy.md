# 8. Concurrency

Like it or not, concurrency has become a core topic in software development. Most professional programmers feel pressure to leverage and master concurrency, because most computers and smart phones now sport multiple core processors.  This means multithreaded applications often outperform singlethreaded ones, and the most effective way to scale performance is to leverage multiple processors. This means code must explicitly be coded to use multiple threads.

### Concurrency Basics

**Concurrency** is essentially multitasking. Multiple actions are happening at the same time and not in sequence to each other. Here's a coffee shop analogy. A single barista receives three orders: a latte, a nitro coffee, and a mocha frappe. She has to prepare each of these one at a time and in that order. She has three tasks and must go through them sequentially.

But now let's say we have *two* baristas in the coffee shop. The work can now be shared. The first barista makes the latte while the second simultaneously makes the nitro coffee. They are both working on two tasks at the same time. Whoever gets done first can then move onto the third order. Each barista is like a **thread**, which executes tasks and does work given to it. Each drink order is a **task**, and each task is claimed by a barista (thread) and then executed.

Concurrent programs really are no different. There are threads that execute code (structured into tasks) line-by-line. However when tasks share mutable objects, the threads can race chaotically to check and modify those object's properties, and you risk getting a *race condition*. This is one reason why multithreading is traditionally hard to master, and experienced developers learn to leverage immutability, synchronization, and clean separation of tasks. Thankfully, RxJava makes concurrency trivial and much safer by abstracting away the complexities of multithreading, and Observables are agnostic to what threads they run on.

In UI development, concurrency is critical for a positive user experience. Typically there is a "UI thread" that is in charge of "painting" the UI and constantly modifying its visuals. JavaFX has the "JavaFX Application Thread" to fulfill this need, and any Observable operators or Subscribers that make changes to the UI must run on this thread. By default, all RxJavaFX Observable factories we worked with run on the JavaFX thread. As we will learn in this chapter, RxJava and RxJavaFX will allow us to painlessly switch emissions between threads at any point in the `Observable` chain.
