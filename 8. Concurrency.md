# 8. Concurrency

Concurrency has become a critical skill in software development. Most computers and smart phones now have multiple core processors, and this means the most effective way to scale performance is to leverage all of them. For this full utilization to happen, code must explicitly be coded for multiple threads that can be worked by multiple cores.

The idea of concurrency is essentially multitasking. Multiple threads execute multiple tasks at the same time. Suppose you had some yard work to do and had three tasks: mow the lawn, trim the trees, and sweep the patio. If you are working alone, there is no way you can do all three of these tasks at the same time. You have to sequentially work on each task one-at-a-time. But if you had two friends or family members to help out, you can get done more quickly as all three of you can execute all three tasks simultaneously. In essence, each person is a thread and each chore is a task.

Even if you have less threads than tasks (such as two threads and three tasks), the two threads can tackle two of the tasks immediately. The first one to get done can then move on to the third task. This is essentially what a thread pool does. It has a fixed number of threads and is given a "queue" of tasks to do. Each thread will take a task, execute it, and then take another. "Reusing" threads and giving them a queue of tasks, rather than creating a thread for each task, is usually more efficient since threads are expensive to create and destroy.

Traditionally, concurrency is difficult to master in Java. A lot can go wrong especially with mutable variables being accessed by multiple threads. Thankfully, RxJava makes concurrency much easier and safer. When you stay within an `Observable` chain, it does not matter what thread emissions happen on (except of course Subscribers and operators affecting JavaFX UI's which need to happen on the JavaFX thread). A major selling point of RxJava is it makes concurrency trivial to compose, and this is helpful to make JavaFX UI's responsive and non-freezing.

>It is recommended to study concurrency without RxJava, just so you are aware of the "gotchas" that can happen with multithreading. Benjamin Winterberg has an [awesome online tutorial](http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/) walking through Java 8 concurrency. If you want deep knowlege in Java concurrnecy, [Java Concurrency in Practice](http://jcip.net/) is an involved but very informative book.

## Using `subscribeOn()`

By default, for a given `Observable` chain, the thread that calls the `subscribe()` method is the thread the `Observable` sends emissions on. For instance, a simple subscription to an `Observable` inside a `main()` method will fire the emissions on the `main` daemon thread.

**Java**

```java
public class JavaLauncher {
    public static void main(String[] args) {
        Observable.range(1,5)
                    .subscribe(i ->
                            System.out.println("Receiving " + i + " on thread "
                                    + Thread.currentThread().getName())
                    );
    }
}
```

**Kotlin**

```kotlin
fun main(args: Array<String>) {
    Observable.range(1,5)
        .subscribe { println("Receiving $it on thread ${Thread.currentThread().name}") }
}
```

**OUTPUT:**

```
Receiving 1 on thread main
Receiving 2 on thread main
Receiving 3 on thread main
Receiving 4 on thread main
Receiving 5 on thread main
```

However, we can easily switch these emissions to happen on another thread using `subscribeOn()`. We can pass a `Scheduler` as an argument which specifies where it gets a thread from. In this case, we can pass `subscribeOn()` an argument of `Schedulers.newThread()`, so it will execute on a new thread for each `Subscriber`.

**Java**

```java
public class JavaLauncher {
    public static void main(String[] args) {
        Observable.range(1,5)
            .subscribeOn(Schedulers.newThread())
            .subscribe(i ->
                    System.out.println("Receiving " + i + " on thread "
                            + Thread.currentThread().getName())
            );

        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

**Kotlin**

```kotlin
fun main(args: Array<String>) {
    Observable.range(1,5)
        .subscribeOn(Schedulers.newThread())
        .subscribe { println("Receiving $it on thread ${Thread.currentThread().name}") }

    TimeUnit.SECONDS.sleep(3)
}
```

**OUTPUT:**

```
Receiving 1 on thread RxNewThreadScheduler-1
Receiving 2 on thread RxNewThreadScheduler-1
Receiving 3 on thread RxNewThreadScheduler-1
Receiving 4 on thread RxNewThreadScheduler-1
Receiving 5 on thread RxNewThreadScheduler-1
```


This way we can declare our `Observable` chain and a `Subscriber`, but then immediately move on without waiting for the emissions to finish. Those are now happening on a new thread named `RxNewThreadScheduler-1`. Notice too we have to call `TimUnit.SECONDS.sleep(3)` to make the `main` thread sleep for 3 seconds. This gives our `Observable` a chance to fire all emissions before the program exits, but you should not have to do this with a JavaFX application since it will indefinitely stay alive.

A critical behavior to note here is that _all_ emissions are happening _sequentially_ on a single `RxNewThreadScheduler-1` thread. Emissions are strictly happening one-after-the-other on a single thread and not racing to call `onNext()` for each step. If this did occur, it would break the [`Observable` contract](http://reactivex.io/documentation/contract.html). In other words, RxJava is not parallel! But we will cover some concurrency tricks with `flatMap()` later to get parallelization without breaking the `Observable` contract.

`subscribeOn()` can be declared anywhere in the `Observable` chain, and it will communicate all the way up to the source what thread to fire emissions on. If you needlessly declare multiple `subscribeOn()` operators in a chain, the left-most one (closest to the source) will win. Later we will cover the `observeOn()` which can switch emissions to a different thread in the middle of the chain.

### Pooling Threads: Choosing a Scheduler

In reality, you should be conservative about using `Schedulers.newThread()` as it creates a new thread for each `Subscriber`. You will notice that if we attach multiple Subscribers to this `Observable`, we are unsurprisingly going to create a new thread for each `Subscriber`.

**Java**

```java
public class JavaLauncher {
    public static void main(String[] args) {
        Observable<Integer> source = Observable.range(1,5)
            .subscribeOn(Schedulers.newThread());

        //Subscriber 1
        source.subscribe(i ->
                System.out.println("Subscriber 1 receiving " + i + " on thread "
                        + Thread.currentThread().getName())
        );

        //Subscriber 2
        source.subscribe(i ->
                System.out.println("Subscriber 2 receiving " + i + " on thread "
                        + Thread.currentThread().getName())
        );

        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

**Kotlin**

```kotlin
fun main(args: Array<String>) {
    val source = Observable.range(1,5)
        .subscribeOn(Schedulers.newThread())

    //Subscriber 1
    source.subscribe { println("Subscriber 1 receiving $it on thread ${Thread.currentThread().name}") }

    //Subscriber 2
    source.subscribe { println("Subscriber 2 receiving $it on thread ${Thread.currentThread().name}") }

    TimeUnit.SECONDS.sleep(3)
}
```

**OUTPUT:**

```
Subscriber 2 receiving 1 on thread RxNewThreadScheduler-2
Subscriber 1 receiving 1 on thread RxNewThreadScheduler-1
Subscriber 2 receiving 2 on thread RxNewThreadScheduler-2
Subscriber 1 receiving 2 on thread RxNewThreadScheduler-1
Subscriber 2 receiving 3 on thread RxNewThreadScheduler-2
Subscriber 1 receiving 3 on thread RxNewThreadScheduler-1
Subscriber 2 receiving 4 on thread RxNewThreadScheduler-2
Subscriber 1 receiving 4 on thread RxNewThreadScheduler-1
Subscriber 2 receiving 5 on thread RxNewThreadScheduler-2
Subscriber 1 receiving 5 on thread RxNewThreadScheduler-1
```
Now we have two threads, `RxNewThreadScheduler-1` and `RxNewThreadScheduler-2`. What if we had 100, or even 1000 Subscribers? This can easily happen if you are flatMapping to hundreds or thousands of Observables.  Threads are very expensive and can tax your machine memory and CPU-wise, so we want to constrain the number of threads.

The most effective way to keep thread creation under control is to "reuse" threads, and you can do this with the different `Schedulers`. A `Scheduler` is RxJava's equivalent to [Java's standard `Executor`](http://tutorials.jenkov.com/java-util-concurrent/executorservice.html), and you can indeed create your own `Scheduler` by passing an `Executor` to the `Schedulers.from()` factory. But for most cases, it is better to use RxJava's standard `Schedulers` as they are optimized to be conservative and efficient for most cases.

#### Computation

If you are doing computation-intensive operations, you will likely want to use `Schedulers.computation()` which will maintain a conservative number of threads to keep the CPU from being taxed.

```java
Observable<Integer> source = Observable.range(1,5)
    .subscribeOn(Schedulers.computation());
```

#### IO

If you are doing a lot of IO-related tasks, like sending web service requests or database queries, these are much less taxing on the CPU and threads can be created more liberally. `Schedulers.io()` is suited for this kind of work. It will add and remove threads depending on how much work is being thrown at it at a given time. But be careful as it will not limit how many threads it creates! As a rule-of-thumb, assume it will create a new thread for each task even if it does reuse threads.

```java
Observable<Integer> source = Observable.range(1,5)
    .subscribeOn(Schedulers.io());
```

#### Immediate

The `Schedulers.immediate()` is the default `Scheduler`, and it will work execute work on the immediate thread declaring the `Subscriber`.

```java
Observable<Integer> source = Observable.range(1,5)
    .subscribeOn(Schedulers.immediate());
```

You will likely not use this `Scheduler` very often since it is used as the default anyway.

#### Trampoline

An interesting `Scheduler` is the `Schedulers.trampoline()`. It will schedule the emissions to happen on the immediate thread, but allow the immediate thread to finish its current task first. In other words, this defers execution of the emissions but will fire them the moment the current thread declaring the subscription is no longer busy.

```java
Observable<Integer> source = Observable.range(1,5)
    .subscribeOn(Schedulers.trampoline());
```

#### JavaFX Scheduler

Finally, the `JavaFxScheduler` is packaged with the RxJavaFX library. It executes the emissions on the JavaFX thread so they can safely make modifications to a UI. It uses a trampoline policy against the JavaFX thread, making it highly resilient and prevents hangups and starvation on the JavaFX thread.

The JavaFX Scheduler is not in the `Schedulers` class, but rather is stored as a singleton in its own class. You can call it like below:

```java
Observable<Integer> source = Observable.range(1,5)
    .subscribeOn(JavaFxScheduler.getInstance());
```

In Kotlin, The RxKotlinFX library can save you some boilerplate by using an extension function instead.

```kotlin
val source = Observable.range(1,5)
    .subscribeOnFx()
```

At the time of writing, all RxJavaFX/RxKotlinFX factories already emit on the `JavaFxScheduler`. Therefore, declaring a `subscribeOn()` against these sources will have no affect. You will need to leverage `observeOn()` to switch to another thread later in the chain, which we will cover shortly.

Also note that the JavaFX thread is already used when declaring UI code, and will be the default `subscribeOn()` thread since it is the immediate thread. Therefore, you will rarely call `subscribeOn()` to specify the JavaFxScheduler. You are more likely to use `observeOn()`.


**Java**

```java
Button button = new Button("Press me");

JavaFxObservable.fromActionEvents(button)
        .subscribeOn(Schedulers.io()) // has no effect
        .subscribe(ae -> System.out.println("You clicked me!"));
```

**Kotlin**

```kotlin
val button = Button("Press me")

button.actionEvents()
        .subscribeOn(Schedulers.io()) // has no effect
        .subscribe { println("You clicked me!") }
```


### Intervals

While we are talking about concurrency, it is worth mentioning there are other factories that already emit on a specific `Scheduler`. For instance, there are factories in both RxJava and JavaFX to emit at a specified time interval.

In RxJava, there is an `Observable.interval()` that will emit a consecutive `long` for every specified interval based on a specified number of `TimeUnit`s. By default, this runs on the `Schedulers.computation()` unless you specify a different one as a third argument.

Here is an application that will increment a `Label` every second (Figure 8.1).

**Java**

```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox root = new VBox();

        Label label = new Label();

        Observable.interval(1, TimeUnit.SECONDS, JavaFxScheduler.getInstance())
                .map(l -> l.toString())
                .subscribe(label::setText);

        root.getChildren().add(label);

        stage.setScene(new Scene(root));

        stage.setMinWidth(60);
        stage.show();
    }
}
```

**Kotlin**

```kotlin
class MyView : View("My View") {

    override val root = vbox {

        minWidth = 60.0

        label {
            Observable.interval(1,TimeUnit.SECONDS, JavaFxScheduler.getInstance())
                .map { it.toString() }
                .subscribe { text = it }
        }
    }
}


```

**OUTPUT:**

```
0
1
2
3
4
```

**Figure 8.1**

![](http://i.imgur.com/oGcGPkE.png)

> You can also use `JavaFxScheduler.interval()` to pass a `Duration` instead of a `TimeUnit`, and schedule on the JavaFX thread out-of-the-box.

Intervals are helpful to create timer-driven Observables, or perform tasks such as periodically driving refreshes at a regular window. If you want all Subscribers do not receive separate interval streams, be sure to use `publish().refCount()` or `publish().autoConnect()` to multicast the same intervals to all.

## Using `observeOn()`

A lot of folks get confused by the difference between `subscribeOn()` and `observeOn()`, but the distinction is quite simple. A `subsribeOn()` instructs the source `Observable` what thread to emit items on. However, the `observeOn()` switches emissions to a different thread at that point in the chain.

In JavaFX, the most common useage of `observeOn()` is to put items back on the JavaFX thread after a compution or IO operation finishes from another thread. Say you wanted to import some expensive data on `Schedulers.io()` and collect it in a `List`, and once it is ready you want to move that `List` emission to the JavaFX thread to feed a `ListView`? That is perfectly doable with an `observeOn()` (Figure 8.2).


**Java**

```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox root = new VBox();

        ListView<String> listView = new ListView<>();

        Observable.just("Alpha","Beta","Gamma","Delta","Epsilon")
                .subscribeOn(Schedulers.io())
                .toList()
                .observeOn(JavaFxScheduler.getInstance())
                .subscribe(list -> listView.getItems().setAll(list));

        root.getChildren().add(listView);

        stage.setScene(new Scene(root));

        stage.show();
    }
}
```

**Kotlin**

```kotlin
class MyView : View("My View") {

    override val root = vbox {

        listview<String> {
            Observable.just("Alpha","Beta","Gamma","Delta","Epsilon")
                .subscribeOn(Schedulers.io())
                .toList()
                .observeOnFx()
                .subscribe { items.setAll(it) }
        }
    }
}
```

**Figure 8.2**

![](http://i.imgur.com/aCJeQ2X.png)

The five Strings are emitted and collected into a `List` on a `Schedulers.io()` thread. But immediately after the `toList()` is an `observeOn()` that takes that `List` and emits it on the JavaFX Scheduler. The placement of the `subscribeOn()` does not matter as it will always instruct the source no matter where it is at. But the placement of the `observeOn()` is key. It switches to a different thread _at that point in the Observable chain_.

This all happens a bit too fast to see this occuring, so let's emulate a long-running database query ([RxJava-JDBC](https://github.com/davidmoten/rxjava-jdbc)) or request ([RxNetty](https://github.com/ReactiveX/RxNetty) or [RxApacheHTTP](https://github.com/ReactiveX/RxApacheHttp)). Use the `delay()` operator to delay the emissions by 3 seconds. Note it subscribes on the `Schedulers.computation()` by default. Having a `subscribeOn()` no longer has any effect. But we can pass the `Schedulers.io()` as a third argument to make it use an IO thread instead (Figure 8.3).


**Java**

```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        VBox root = new VBox();

        ListView<String> listView = new ListView<>();

        Observable.just("Alpha","Beta","Gamma","Delta","Epsilon")
                .delay(3,TimeUnit.SECONDS, Schedulers.io())
                .toList()
                .observeOn(JavaFxScheduler.getInstance())
                .subscribe(list -> listView.getItems().setAll(list));

        root.getChildren().add(listView);

        stage.setScene(new Scene(root));

        stage.show();
    }
}
```

**Kotlin**

```kotlin
class MyView : View("My View") {

    override val root = vbox {

        listview<String> {
            Observable.just("Alpha","Beta","Gamma","Delta","Epsilon")
                .delay(3,TimeUnit.SECONDS, Schedulers.io())
                .toList()
                .observeOnFx()
                .subscribe { items.setAll(it) }
        }
    }
}
```

**Figure 8.3**
![](http://i.imgur.com/HWH8Kit.png) ![](http://i.imgur.com/DaEOAZZ.png)

In Figure 8.3, notice that our UI is empty for 3 seconds before it is finally populated. The data import and collecting into a `List` happens on the IO thread, and then it is safely emitted on the JavaFX thread where it is populated into the `List`. In a real-world case, the JavaFX thread does not hold up the UI from displaying due to this operation keeping it busy. If we had more controls we would see the UI is completely interactive as well during this background operation.

### Chaining Multiple `observeOn()` Calls

It is also not uncommon to use multiple `observeOn()` calls. Here is a more real-life example. Let's say you want to create an application that displays the text response (such as JSON) from a URL. This has the potential to create an unrespsonsive application that freezes while it is fetching the request. But using an `observeOn()` we can switch this work from the FX thread to an IO therad, then call another `observeOn()` afterwards to put it back on the FX thread.

**Java**

```java

public class JavaApp extends Application {
    @Override
    public void start(Stage stage) throws Exception {
        VBox vBox = new VBox();
        Label label = new Label("Input URL");
        TextField input = new TextField();
        TextArea output = new TextArea();
        Button button = new Button("Submit");

        output.setWrapText(true);

        JavaFxObservable.fromActionEvents(button)
                .map(ae -> input.getText())
                .observeOn(Schedulers.io())
                .map(path -> getResponse(path))
                .observeOn(JavaFxScheduler.getInstance())
                .subscribe(r -> output.setText(r));

        vBox.getChildren().setAll(label,input,output,button);
        stage.setScene(new Scene(vBox));
        stage.show();

    }
    private static String getResponse(String path) {
        try {
            return new Scanner(new URL(path).openStream(), "UTF-8").useDelimiter("\\A").next();
        } catch (Exception e) {
            return e.getMessage();
        }
    }
}
```

**Kotlin**

```kotlin
class MyApp: App(TestView::class)

class TestView : View("My View") {

    override val root =  vbox {

        label("Input URL")
        val input = textfield()
        val output = textarea {
            isWrapText = true
        }

        button("Submit").actionEvents()
            .map { input.text }
            .observeOn(Schedulers.io())
            .map {
                URL(input.text).readText()
            }.observeOnFx()
            .subscribe {
                output.text = it
            }
    }
}
```

**Figure 8.4**

![](http://i.imgur.com/z8Lv7hM.png)


You can then put in a URL (such as "https://api.github.com/users/thomasnield/starred") and then click the "Submit" `Button` to process it. You will notice the UI stays interactive and after a few seconds will put the response in the `TextArea` (Figure 8.5).

**Figure 8.5**

![](http://i.imgur.com/1PHm7W1.png)

Of course, you can click the "Submit" `Button` multiple times and that could queue up the requests in an undesirable way. But at least the work is kept off the UI thread. In the next chapter we will learn about the `switchMap()` to mitigate excessive user inputs and kill previous subscriptions so only the latest one is chased after.

But we will take a more simpler strategy for now to prevent this from happening.


### Using doOnXXX() Operators

It might be helpful to create a few "side effects" beyond the `Subscriber` for this HTTP request application we just built. In other words, we want to put Subscribers in the middle of the chain at certain points. It might be helpful to change the "Submit" Button's text to "WORKING" when a request is being processed, as well as disable it so no more requests can be sent until the current one completes.

RxJava has `doOnXXX()` operators that allow you to "peek" into an `Observable` at that point in the chain. For instance, you can use `doOnNext()` and pass a lambda to do something with each emission, like print it. `doOnCompleted()` will fire a specified action when that point of the chain received a completion notification, and `doOnError()` will do the same for an error event. Here is a complete list of these `doOnXXX()` operators in RxJava.

|Operator|Example|Description|
|---|---|---|
|doOnNext()|myObs.doOnNext(i -> System.out.println(i))|Performs an action for each emission|
|


To disable the `Button` an change its text during processing, you might be tempted to use the `doOnNext()` to achieve this.

**Java**

```java
public class JavaApp extends Application {
    @Override
    public void start(Stage stage) throws Exception {
        VBox vBox = new VBox();
        Label label = new Label("Input URL");
        TextField input = new TextField();
        TextArea output = new TextArea();
        Button button = new Button("Submit");

        output.setWrapText(true);

        JavaFxObservable.fromActionEvents(button)
                .map(ae -> input.getText())
                .observeOn(Schedulers.io())
                .doOnNext(path -> {
                    button.setText("BUSY");
                    button.setDisable(true);
                })
                .map(path -> getResponse(path))
                .observeOn(JavaFxScheduler.getInstance())
                .subscribe(r -> {
                    output.setText(r);
                    button.setText("Submit");
                    button.setDisable(true);
                });

        vBox.getChildren().setAll(label,input,output,button);
        stage.setScene(new Scene(vBox));
        stage.show();

    }
    private static String getResponse(String path) {
        try {
            return new Scanner(new URL(path).openStream(), "UTF-8").useDelimiter("\\A").next();
        } catch (Exception e) {
            return e.getMessage();
        }
    }
}
```

**Kotlin**

```kotlin

class TestView : View("My View") {

    override val root =  vbox {

        label("Input URL")
        val input = textfield()
        val output = textarea {
            isWrapText = true
        }

        val submitButton = button("Submit")

        submitButton.actionEvents()
            .map { input.text }
            .observeOn(Schedulers.io())
            .doOnNext {
                submitButton.text = "BUSY"
                submitButton.isDisable = true
            }
            .map {
                URL(input.text).readText()
            }.observeOnFx()
            .subscribe {
                output.text = it
                submitButton.text = "Submit"
                submitButton.isDisable = true
            }
    }
}
```

But if you try to execute a request with this modification, you will get an error indicating that the `submitButton` is not being modified on the FX thread. This is occuring because the above code switched to the IO `Scheduler` and an IO thread (not the FX thread) is trying to modify the `Button`. You could move this `doOnNext()` operator before the `observeOn(Schedulers.io())` and that would address the issue, but there will be times where you must do it deep in an `Observable` chain that is already on another thread. This can happen if you need to update a `ProgressBar` when work is happening on another thread, for instance.

Currently for Java, you can wrap all the actions for the `doOnNext()` in a `Platform.runLater()`. In Kotlin, there is a convenient extension function `doOnNextFx()` that will accomplish this for you.

**Java**

```java
public class JavaApp extends Application {
    @Override
    public void start(Stage stage) throws Exception {
        VBox vBox = new VBox();
        Label label = new Label("Input URL");
        TextField input = new TextField();
        TextArea output = new TextArea();
        Button button = new Button("Submit");

        output.setWrapText(true);

        JavaFxObservable.fromActionEvents(button)
                .map(ae -> input.getText())
                .observeOn(Schedulers.io())
                .doOnNext(path -> Platform.runLater(() -> {
                    button.setText("BUSY");
                    button.setDisable(true);
                }))
                .map(path -> getResponse(path))
                .observeOn(JavaFxScheduler.getInstance())
                .subscribe(r -> {
                    output.setText(r);
                    button.setText("Submit");
                    button.setDisable(true);
                });

        vBox.getChildren().setAll(label,input,output,button);
        stage.setScene(new Scene(vBox));
        stage.show();

    }
    private static String getResponse(String path) {
        try {
            return new Scanner(new URL(path).openStream(), "UTF-8").useDelimiter("\\A").next();
        } catch (Exception e) {
            return e.getMessage();
        }
    }
}
```

**Kotlin**

```kotlin
class TestView : View("My View") {

    override val root =  vbox {

        label("Input URL")
        val input = textfield()
        val output = textarea {
            isWrapText = true
        }

        val submitButton = button("Submit")

        submitButton.actionEvents()
            .map { input.text }
            .observeOn(Schedulers.io())
            .doOnNextFx {
                submitButton.text = "BUSY"
                submitButton.isDisable = true
            }
            .map {
                URL(input.text).readText()
            }.observeOnFx()
            .subscribe {
                output.text = it
                submitButton.text = "Submit"
                submitButton.isDisable = true
            }
    }
}
```

In RxKotlinFX, there are `doOnXXXFx()` operators that run on the JavaFX thread, regardless of which thread the operator is called on. You can achieve this also with RxJavaFX, but Java does not have have extension functions.

> Java does not have extension functions like Kotlin. But RxJava does have a `compose()` operator that you can pass a `Transformer` to, as well as a `lift()` operator to create custom operators. Between these two methods, it is possible to create your own operators for RxJava. These are beyond the scope of this book though. You can read about [creating your own operators here](https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators).
