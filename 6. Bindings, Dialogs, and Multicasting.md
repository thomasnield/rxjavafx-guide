# 6. Bindings, Dialogs, and Multicasting

There are situations where JavaFX will want a `Binding` rather than an RxJava `Observable` or `Subscriber`, and we will cover some streamlined utilities to meet this need. We will also cover JavaFX Dialogs and how to use them reactively.Finally we will encounter the concept of multicasting, an RxJava topic that will increasingly become critical as you advance in reactive JavaFX.


## Bindings and RxJava

In JavaFX, there is a `Binding` feature that allows you to synchronize JavaFX `ObservableValue` items by their `bind()` and `bindBidirectional()` methods. You can also express transformations of an `ObservableValue` and bind on those transformations. RxJavaFX eliminates most need cases for Bindings. As you probably observed, it already provides a robust and expressive way to make controls communicate their changes.

For instance, you can leverage bindings to disable a `Button` when a `TextField` does not contain six characters.

**Java**

```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {
        VBox root = new VBox();

        Label label = new Label("Input a 6-character String");

        TextField input = new TextField();
        Button button = new Button("Proceed");

        button.disableProperty().bind(
                Bindings.createBooleanBinding(() -> input.getText().length() != 6,
                        input.textProperty())
        );
        root.getChildren().addAll(label,input,button);
        stage.setScene(new Scene(root));
        stage.show();
    }
}
```

**Kotlin**

```kotlin
class MyApp: App(MyView::class)

class MyView: View() {

    override val root = vbox {

        label("Input a 6-character String")

        val input = textfield()
        val button = button("Proceed")

        button.disableProperty().bind(
                input.textProperty().booleanBinding { it?.length != 6 }
        )
    }
}
```

**Figure 6.1** Using bindings to disable a `Button` unless a `TextField` is six characters

![](http://i.imgur.com/szdQEZv.png) ![](http://i.imgur.com/IHP7Kcj.png)


Of course, the need for `Binding` in this case is eliminated thanks to RxJava. Knowing what you know now, RxJava creates a more streamlined and inuitive way to "push" the `input` text values, map them to a boolean expression, and finally to a `Subscriber` that sets the `disableProperty()` of the `Button` to that boolean value.


**Java**

```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {
        VBox root = new VBox();

        Label label = new Label("Input a 6-character String");

        TextField input = new TextField();
        Button button = new Button("Proceed");

        JavaFxObservable.fromObservableValue(input.textProperty())
                .map(s -> s.length() != 6)
                .subscribe(b -> button.disableProperty().setValue(b));

        root.getChildren().addAll(label,input,button);
        stage.setScene(new Scene(root));
        stage.show();
    }
}
```

**Kotlin**

```kotlin
class MyApp: App(MyView::class)

class MyView: View() {

    override val root = vbox {

        label("Input a 6-character String")

        val input = textfield()
        val button = button("Proceed")

        input.textProperty().toObservable()
            .map { it.length  != 6 }
            .subscribe { button.disableProperty().set(it) }
    }
}
```

If you are fluent in Rx, this is much more intuitive. It is also much more flexible and a given `ObservableValue` remains openly mutable rather than being bound to another `ObservableValue`.

But if you need to create a `Binding`, there is a factory/extension function to turn an RxJava `Observable<T>` into a JavaFX `Binding<T>`. Here we turn the above `Observable` chain into a `Binding<Boolean>` that the `disableProperty()` can be bound to.

**Java**

```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {
        VBox root = new VBox();

        Label label = new Label("Input a 6-character String");

        TextField input = new TextField();
        Button button = new Button("Proceed");

        Binding<Boolean> binding = JavaFxSubscriber.toBinding(
            JavaFxObservable.fromObservableValue(input.textProperty())
                    .map(s -> s.length() != 6)
        );

        button.disableProperty().bind(binding);

        root.getChildren().addAll(label,input,button);
        stage.setScene(new Scene(root));
        stage.show();
    }
}
```

**Kotlin**

```kotlin
class MyApp: App(MyView::class)

class MyView: View() {

    override val root = vbox {

        label("Input a 6-character String")

        val input = textfield()
        val button = button("Proceed")

        val binding = input.textProperty().toObservable()
            .map { it.length  != 6 }
            .toBinding()

        button.disableProperty().bind(binding)
    }
}
```

The `Binding<T>` is essentially a `Subscriber` that can be bound to other JavaFX ObservableValues. The above example is somewhat contrived since the `Binding` is not really necessary, but let's take a look where Bindings are: TableViews.

Say you have the given domain type `Person`. It has a `birthday` property that holds a `LocalDate`. The `getAge()` is an `Observable` driven off of it and converted to a `Binding<Long>`. When you change the `birthday`, it will push a new `Long` value to the age `Binding` (Figure 6.2).

**Java**

```java
public final class Person {

       private final StringProperty name =
               new SimpleStringProperty();

       private final ObjectProperty<LocalDate> birthday =
               new SimpleObjectProperty<>();

       private final Binding<Long> ageBinding = JavaFxSubscriber.toBinding(
               JavaFxObservable.fromObservableValue(birthdayProperty())
               .map(dt -> ChronoUnit.YEARS.between(dt,LocalDate.now()))
               );

       Person(String name, LocalDate birthday) {
           this.name.setValue(name);
           this.birthday.setValue(birthday);
       }

       public StringProperty nameProperty() {
           return name;
       }

       public ObjectProperty<LocalDate> birthdayProperty() {
           return birthday;
       }

       public Binding<Long> getAge() {
           return ageBinding;
       }
   }
```

**Kotlin**

```kotlin
class Person(name: String, birthday: LocalDate) {
    var name by property(name)
    fun nameProperty() = getProperty(Person::name)

    var birthday by property(birthday)
    fun birthdayProperty() = getProperty(Person::birthday)

    val age = birthdayProperty().toObservable()
            .map { ChronoUnit.YEARS.between(it,LocalDate.now()) }
            .doOnNext { println(it) }
            .toBinding()
}
```


Now if you put a few instances of these in a `TableView`, each row will then come to life (Figure 6.2).

**Java**

```java
public final class JavaFxApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {

        TableView<Person> table = new TableView<>();
        table.setEditable(true);

        table.getItems().setAll(
                new Person("Thomas Nield",LocalDate.of(1989,1,18)),
                new Person("Sam Tulsa",LocalDate.of(1980,5,12)),
                new Person("Ron Johnson",LocalDate.of(1975,3,8))
        );

        TableColumn<Person,String> nameCol = new TableColumn<>("Name");
        nameCol.setCellValueFactory(v -> v.getValue().nameProperty());

        TableColumn<Person,LocalDate> birthdayCol = new TableColumn<>("Birthday");
        birthdayCol.setCellValueFactory(v -> v.getValue().birthdayProperty());
        birthdayCol.setCellFactory(TextFieldTableCell.forTableColumn(new LocalDateStringConverter()));

        TableColumn<Person,Long> ageCol = new TableColumn<>("Age");
        ageCol.setCellValueFactory(v -> v.getValue().getAge());

        table.getColumns().addAll(nameCol,birthdayCol,ageCol);
        stage.setScene(new Scene(table));
        stage.show();
    }
}
```

**Kotlin**

```kotlin
class MyApp: App(MyView::class)

class MyView: View() {

    override val root = tableview<Person> {
        isEditable = true
        items.setAll(
                Person("Thomas Nield",LocalDate.of(1989,1,18)),
                Person("Sam Tulsa",LocalDate.of(1980,5,12)),
                Person("Ron Johnson",LocalDate.of(1975,3,8))
        )

        column("Name",Person::nameProperty)
        column("Birthday",Person::birthdayProperty)
                .useTextField(LocalDateStringConverter())
        column("Age",Person::age)
    }
}
```

**Figure 6.2**

![](http://i.imgur.com/dZhI7C1.png)

When you edit the "Birthday" field for a given row, you will see the "Age" field update automatically. This is because the age `Binding` is driven off an RxJava `Observable` built off the birthday `Property`.

### Handling Errors with Reactive Bindings

When you create a JavaFX `Binding<T>` off an `Observable<T>`, it usually is a good idea to pass a lambda to handle the `onError()` event. Otherwise errors may go unnoticed and unhandled. Try to make this part of your practices, even if we do not do this for the rest of the chapter for sake of brevity.

**Java**

```java
private final Binding<Long> ageBinding = JavaFxSubscriber.toBinding(
        JavaFxObservable.fromObservableValue(birthdayProperty())
          .map(dt -> ChronoUnit.YEARS.between(dt,LocalDate.now())),
        Throwable::printStackTrace
        );
```

**Kotlin**

```kotlin
val age = birthdayProperty().toObservable()
        .map { ChronoUnit.YEARS.between(it,LocalDate.now()) }
        .doOnNext { println(it) }
        .toBinding { it.printStackTrace() }
```


### Disposing Bindings

If we are going to remove records from a `TableView`. we will need to dispose any Bindings that exist on each one. This will `unsubscribe()` the `Binding` from the RxJava `Observable` to prevent any memory leaks.

It is good practice is to put a method on your domain type that will dispose all Bindings on that instance. For our `Person`, we will want to `dispose()` the age `Binding`.

**Java**

```java
public final class Person {

    private final StringProperty name =
            new SimpleStringProperty();

    private final ObjectProperty<LocalDate> birthday =
            new SimpleObjectProperty<>();

    private final Binding<Long> ageBinding = JavaFxSubscriber.toBinding(
            JavaFxObservable.fromObservableValue(birthdayProperty())
            .map(dt -> ChronoUnit.YEARS.between(dt,LocalDate.now())),
            Throwable::printStackTrace
            );

    Person(String name, LocalDate birthday) {
        this.name.setValue(name);
        this.birthday.setValue(birthday);
    }

    public StringProperty nameProperty() {
        return name;
    }

    public ObjectProperty<LocalDate> birthdayProperty() {
        return birthday;
    }

    public Binding<Long> getAge() {
        return ageBinding;
    }

    public void dispose() {
        ageBinding.dispose();
    }
}
```

**Kotlin**

```kotlin
class Person(name: String, birthday: LocalDate) {
    var name by property(name)
    fun nameProperty() = getProperty(Person::name)

    var birthday by property(birthday)
    fun birthdayProperty() = getProperty(Person::birthday)

    val age = birthdayProperty().toObservable()
            .map { ChronoUnit.YEARS.between(it,LocalDate.now()) }
            .doOnNext { println(it) }
            .toBinding { it.printStackTrace() }

    fun dispose() = age.dispose()
}
```

Whever you remove items from the `TableView`, call `dispose()` on each `Person`.

If your domain type has several Bindings, you can add them all to a `CompositeBinding`
